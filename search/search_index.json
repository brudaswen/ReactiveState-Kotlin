{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ReactiveState for Kotlin Multiplatform and Android \u00b6 Easy reactive state management and ViewModels for Kotlin Multiplatform. No boilerplate. Compatible with Android. ReactiveState-Kotlin provides these foundations for building multiplatform ViewModels and lower-level logic: reactive programming : everything is recomputed/updated automatically based on straightforward code demand-driven programming : resource-consuming computations and values are allocated on-demand and disposed when not needed multiplatform : share your ViewModels and reactive state handling logic between all platforms event handling : simple events based on interfaces (more composable and less boilerplate than sealed classes) automatic error catching : no more forgotten try-catch or copy-pasted error handling logic all over the place coroutine-based unit tests : worry no more about passing around CoroutineDispatcher s everywhere lifecycle handling state restoration See the ReactiveState documentation for more details. Supported platforms \u00b6 android, jvm, ios, tvos, watchos, macosArm64, macosX64, mingwX64, linuxX64 Installation \u00b6 Add the package to your build.gradle \u2018s dependencies {} : dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:reactivestate-bom:VERSION\" ) // Leave out the version number from now on: implementation \"com.ensody.reactivestate:reactivestate\" // Utils for unit tests that want to use coroutines implementation \"com.ensody.reactivestate:reactivestate-test\" // Note: kotlin-coroutines-test only supports the \"jvm\" target, // so reactivestate-test has the same limitation } Also, make sure you\u2019ve integrated the Maven Central repo, e.g. in your root build.gradle : subprojects { repositories { // ... mavenCentral () // ... } } Quick intro \u00b6 The following two principles are here to give you a quick idea of the reactive programming aspect only. The \u201cGuide\u201d section in the documentation describes how to work with the more advanced aspects like multiplatform ViewModels, lifecycle handling, etc. Note: While the discussion is about StateFlow , you can also use LiveData or even implement extensions for other observable values. Observing StateFlow \u00b6 Imagine you have an input form with first and last name and want to observe two StateFlow values at the same time: isFirstNameValid: StateFlow<Boolean> isLastNameValid: StateFlow<Boolean> This is how you\u2019d do it by using the autoRun function: autoRun { submitButton . isEnabled = get ( isFirstNameValid ) && get ( isLastNameValid ) } With get(isFirstNameValid) you retrieve isFirstNameValid.value and at the same time tell autoRun to re-execute the block whenever the value is changed. That code is similar to writing this: lifecycleScope . launchWhenStarted { isFirstNameValid . combine ( isLastNameValid ) { firstNameValid , lastNameValid -> firstNameValid to lastNameValid } . conflate () . collect { ( firstNameValid , lastNameValid ) -> try { submitButton . isEnabled = firstNameValid && lastNameValid } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { onError ( e ) } } } Reactive StateFlow / reactive data \u00b6 The same principle can be used to create a derived , reactive StateFlow : val isFormValid : StateFlow < Boolean > = derived { get ( isFirstNameValid ) && get ( isLastNameValid ) } Now you can use autoRun { submitButton.isEnabled = get(isFormValid) } in the rest of your code. Going even further, isFirstNameValid itself would usually also be the result of a derived computation. So, you can have multiple layers of reactive derived StateFlow s. Relation to Jetpack Compose / Flutter / React \u00b6 Reactive UI frameworks like Jetpack Compose automatically rebuild the UI whenever e.g. a StateFlow changes. So, in the UI layer autoRun can usually be replaced with a Composable . However, below the UI your data still needs to be reactive, too. Here ReactiveState provides derived to automatically recompute a StateFlow based on other StateFlow s. This pattern is very useful in practice and provides the perfect foundation for frameworks like Jetpack Compose which primarily focus on the UI aspect. ReactiveState\u2019s derived and autoRun provide the same reactivity for your data and business logic. In Jetpack Compose you even have derivedStateOf which is very similar to derived . So, you can choose whether you want to build your business logic based on the official coroutines library ( StateFlow / derived ) or Jetpack Compose ( State / derivedStateOf ). However, the coroutines library has the advantage that it\u2019s available for more platforms and it\u2019s fully independent of any UI frameworks. Finally, most open-source non-UI libraries will probably be based on coroutines, so StateFlow based code might also be better for compatibility/interoperability. In other words, the combination of both solutions used together results in a fully reactive, multiplatform codebase - which improves code simplicity and avoids many bugs. Moreover, Jetpack Compose currently doesn\u2019t provide any multiplatform ViewModel support or any large-scale architecture. So, this library solves that by providing BaseReactiveState for ViewModels. It also comes with a lifecycle-aware event system ( eventNotifier ) and loading state handling (so you can track one or multiple different loading indicators based on coroutines that you launch). See also \u00b6 This library is based on reactive_state for Flutter and adapted to Kotlin Multiplatform and Android patterns. License \u00b6 Copyright 2022 Ensody GmbH, Waldemar Kornewald Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#reactivestate-for-kotlin-multiplatform-and-android","text":"Easy reactive state management and ViewModels for Kotlin Multiplatform. No boilerplate. Compatible with Android. ReactiveState-Kotlin provides these foundations for building multiplatform ViewModels and lower-level logic: reactive programming : everything is recomputed/updated automatically based on straightforward code demand-driven programming : resource-consuming computations and values are allocated on-demand and disposed when not needed multiplatform : share your ViewModels and reactive state handling logic between all platforms event handling : simple events based on interfaces (more composable and less boilerplate than sealed classes) automatic error catching : no more forgotten try-catch or copy-pasted error handling logic all over the place coroutine-based unit tests : worry no more about passing around CoroutineDispatcher s everywhere lifecycle handling state restoration See the ReactiveState documentation for more details.","title":"ReactiveState for Kotlin Multiplatform and Android"},{"location":"#supported-platforms","text":"android, jvm, ios, tvos, watchos, macosArm64, macosX64, mingwX64, linuxX64","title":"Supported platforms"},{"location":"#installation","text":"Add the package to your build.gradle \u2018s dependencies {} : dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:reactivestate-bom:VERSION\" ) // Leave out the version number from now on: implementation \"com.ensody.reactivestate:reactivestate\" // Utils for unit tests that want to use coroutines implementation \"com.ensody.reactivestate:reactivestate-test\" // Note: kotlin-coroutines-test only supports the \"jvm\" target, // so reactivestate-test has the same limitation } Also, make sure you\u2019ve integrated the Maven Central repo, e.g. in your root build.gradle : subprojects { repositories { // ... mavenCentral () // ... } }","title":"Installation"},{"location":"#quick-intro","text":"The following two principles are here to give you a quick idea of the reactive programming aspect only. The \u201cGuide\u201d section in the documentation describes how to work with the more advanced aspects like multiplatform ViewModels, lifecycle handling, etc. Note: While the discussion is about StateFlow , you can also use LiveData or even implement extensions for other observable values.","title":"Quick intro"},{"location":"#observing-stateflow","text":"Imagine you have an input form with first and last name and want to observe two StateFlow values at the same time: isFirstNameValid: StateFlow<Boolean> isLastNameValid: StateFlow<Boolean> This is how you\u2019d do it by using the autoRun function: autoRun { submitButton . isEnabled = get ( isFirstNameValid ) && get ( isLastNameValid ) } With get(isFirstNameValid) you retrieve isFirstNameValid.value and at the same time tell autoRun to re-execute the block whenever the value is changed. That code is similar to writing this: lifecycleScope . launchWhenStarted { isFirstNameValid . combine ( isLastNameValid ) { firstNameValid , lastNameValid -> firstNameValid to lastNameValid } . conflate () . collect { ( firstNameValid , lastNameValid ) -> try { submitButton . isEnabled = firstNameValid && lastNameValid } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { onError ( e ) } } }","title":"Observing StateFlow"},{"location":"#reactive-stateflow-reactive-data","text":"The same principle can be used to create a derived , reactive StateFlow : val isFormValid : StateFlow < Boolean > = derived { get ( isFirstNameValid ) && get ( isLastNameValid ) } Now you can use autoRun { submitButton.isEnabled = get(isFormValid) } in the rest of your code. Going even further, isFirstNameValid itself would usually also be the result of a derived computation. So, you can have multiple layers of reactive derived StateFlow s.","title":"Reactive StateFlow / reactive data"},{"location":"#relation-to-jetpack-compose-flutter-react","text":"Reactive UI frameworks like Jetpack Compose automatically rebuild the UI whenever e.g. a StateFlow changes. So, in the UI layer autoRun can usually be replaced with a Composable . However, below the UI your data still needs to be reactive, too. Here ReactiveState provides derived to automatically recompute a StateFlow based on other StateFlow s. This pattern is very useful in practice and provides the perfect foundation for frameworks like Jetpack Compose which primarily focus on the UI aspect. ReactiveState\u2019s derived and autoRun provide the same reactivity for your data and business logic. In Jetpack Compose you even have derivedStateOf which is very similar to derived . So, you can choose whether you want to build your business logic based on the official coroutines library ( StateFlow / derived ) or Jetpack Compose ( State / derivedStateOf ). However, the coroutines library has the advantage that it\u2019s available for more platforms and it\u2019s fully independent of any UI frameworks. Finally, most open-source non-UI libraries will probably be based on coroutines, so StateFlow based code might also be better for compatibility/interoperability. In other words, the combination of both solutions used together results in a fully reactive, multiplatform codebase - which improves code simplicity and avoids many bugs. Moreover, Jetpack Compose currently doesn\u2019t provide any multiplatform ViewModel support or any large-scale architecture. So, this library solves that by providing BaseReactiveState for ViewModels. It also comes with a lifecycle-aware event system ( eventNotifier ) and loading state handling (so you can track one or multiple different loading indicators based on coroutines that you launch).","title":"Relation to Jetpack Compose / Flutter / React"},{"location":"#see-also","text":"This library is based on reactive_state for Flutter and adapted to Kotlin Multiplatform and Android patterns.","title":"See also"},{"location":"#license","text":"Copyright 2022 Ensody GmbH, Waldemar Kornewald Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 5.2.1 \u00b6 Made Wrapped a Serializable on JVM. Added Serializable interface that maps to the JVM Serializable and is usable from commonMain . 5.2.0 \u00b6 Extracted non-Android code into reactivestate-core(-test) modules, so you can use ReactiveState with minimal dependencies. Added MutableStateFlow.afterUpdate to complete the API introduced in version 5.1.0. 5.1.3 \u00b6 Upgraded to Kotlin 1.7.21. 5.1.2 \u00b6 Downgraded to Kotlin 1.7.20 because of huge compilation speed degradation on iOS targets and incompatibility with Compose. 5.1.1 \u00b6 Improved Swift compatibility of eventNotifier by making the lambdas non- suspend . 5.1.0 \u00b6 Added MutableStateFlow.beforeUpdate and MutableStateFlow.withSetter setter interceptors. Upgraded to Kotlin 1.8.0. Due to the deprecation of the old JS compiler in Kotlin 1.8.0 the code has switched to the IR compiler. 5.0.2 \u00b6 Upgraded to Kotlin 1.7.20, kotlinx.coroutines 1.6.4, androidx.activity 1.6.0, androidx.fragment 1.5.3. Upgraded to Android SDK 33. The experimental reactivestate-compose module is not published in this release due to a Kotlin/Compose compiler bug. 5.0.1 \u00b6 Adjusted EventNotifierTest / ReactiveStateTest to be consistent with the coroutines test lib behavior. You have to call runCurrent() to execute any coroutines launched from the ViewModel\u2019s init block. 5.0.0 \u00b6 Upgraded to kotlinx.coroutines 1.6.1. You might need to adjust your unit tests to take behavioral differences into account. Upgraded to Jetpack Compose 1.1.1. Upgraded to Kotlin 1.6.20. CoroutineTest.runBlockingTest was deprecated and you should now use CoroutineTest.runTest . Similarly, testCoroutineScope => testScope and testCoroutineDispatcher => testDispatcher . Use CoroutineTest.testScope only for coroutines that will terminate. For ReactiveStateTest you should use CoroutineTest.mainScope which gets canceled at the end of each test run. Native targets are compiled using the experimental memory manager. The reactivestate-test module can now be used with all targets instead of just JVM. Added a few more targets like macosArm64 and iosSimulatorArm64. Moved get(LiveData) to the com.ensody.reactivestate package, so you don\u2019t need to think twice about where you want to import from. 4.7.0 \u00b6 Added Throwable.throwIfFatal() , Throwable.isFatal() and runCatchingNonFatal to deal with fatal errors like CancellationException in a simpler and platform-specific way. 4.6.2 \u00b6 Fixed derived not replaying the current value. 4.6.1 \u00b6 Fixed derived and derivedWhileSubscribed bug when used with multiple collectors. Fixed derived with WhileSubscribed subscribe/unsubscribe/re-subscribe bug. 4.6.0 \u00b6 Added derived and derivedWhileSubscribed variants which don\u2019t need a CoroutineScope , so you don\u2019t need to infect your business logic with scopes. 4.5.0 \u00b6 Upgraded to Kotlin 1.6.10 and Jetpack Compose 1.1.0-rc01. Internal improvements. 4.4.0 \u00b6 Added experimental Jetpack Compose support (currently Android-only). By adding com.ensody.reactivestate:reactivestate-compose to your dependencies and you can use the viewModel { MyViewModel() } and reactiveState { ... } Composable s. 4.3.2 \u00b6 Fixed race condition with autoRun \u2018s observables being changed during run. 4.3.1 \u00b6 Fixed race condition with derived where the observed StateFlow gets changed during first run. 4.3.0 \u00b6 Added @DependencyAccessor annotation to ensure the DI pattern is respected instead of the service locator pattern. 4.2.1 \u00b6 Fixed recursively changing the value of a MutableValueFlow from within the collect block (change->emit->change). Previously this could lead to a deadlock because the first change is still locking the MutableValueFLow . 4.2.0 \u00b6 Added OnReactiveStateAttached interface to allow customizing by reactiveState behavior. 4.1.0 \u00b6 Added MutableValueFlow<Int>.incrementFrom(flow: StateFlow<Int>) extension function to e.g. sum multiple loading states into one MutableValueFlow<Int> . 4.0.0 \u00b6 This release adds support for Kotlin Multiplatform and introduces a multiplatform ReactiveState ViewModel. Breaking changes: The modules have been restructured and renamed: reactivestate-bom (previously dependency-versions-bom) reactivestate (previously core and reactivestate) reactivestate-test (previously core-test) CoroutineTestRule is now a simple class that you can either derive from or add as an attribute. CoroutineTest has become independent of JUnit and inherits from CoroutineTestRule . The coroutineTestRule attribute has been replaced with direct testCoroutineScope and testCoroutineDispatcher attributes inherited from the new CoroutineTestRule . The withLoading concept in autoRun , CoroutineLauncher etc. has become more flexible to allow tracking separate loading states. Removed ReducingStateFlow as part of the simplified loading state concept. Non-breaking changes: Added a multiplatform ViewModel ReactiveState (interface), BaseReactiveState (base class). This is actually a broader concept that can be used for any living object that can launch coroutines, automatically handles errors, triggers events, and tracks loading states. Added a multiplatform buildViewModel extension function for creating such a ViewModel on an Activity and Fragment. Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers: onCreate , onCreateView , onCreateViewOnce , onDestroyView , onDestroyViewOnce . MutableValueFlow.replaceLocked returns the previous value now. Known limitations which will be solved with later releases: On non-JVM platforms, dispatchers.io currently equals Dispatchers.Default . This primarily affects MutableValueFlow : Internally, all uses of the JVM-only synchronized have been replaced with a spinlock Mutex since they were only utilized for very tiny blocks of code which normally don\u2019t even have any parallel access. Be careful about doing too large computations in combination with highly concurrent updates via replaceLocked , though. Changelog of preview releases: 4.0.0-dev.4: Fixed build failures due to Jacoco integration. 4.0.0-dev.3: Removed ReducingStateFlow . Publish iOS/macOS builds. 4.0.0-dev.2: Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers Removed LoadingStateTracker . Replaced CoroutineLauncher.isAnyLoading and generalLoading with a simple loading: MutableValueFlow<Int> . MutableValueFlow.replaceLocked returns the previous value now. MutableValueFlow.increment / decrement now have an optional amount argument to increment by more than 1. Also, they return the previous value. 4.0.0-dev.1: This preview release comes without macOS/iOS builds. A port of the CI pipeline is in progress. 3.9.0 \u00b6 Added @ExperimentalReactiveStateApi annotation to mark experimental APIs. Explicitly marked SuspendMutableValueFlow as experimental and changed its constructor to take the default value instead of a delegating MutableValueFlow . Turned SuspendMutableValueFlow into an interface and constructor/factory function. 3.8.3 \u00b6 Fixed argument inconsistency in SuspendMutableValueFlow.replace . 3.8.2 \u00b6 Fixed state restoration with SavedStateHandleStore . 3.8.1 \u00b6 Fixed support for nullable values in SavedStateHandleStore . 3.8.0 \u00b6 Added by propertyName and by lazyProperty helpers simplifying ReadOnlyProperty . 3.7.0 \u00b6 MutableValueFlow \u2018s constructor now optionally takes a setter lambda function which is executed before emitting a new value. This allows observing / reacting to changes without needing a CoroutineScope . Added val Fragment/Activity.savedInstanceState helper which gives you access to a StateFlowStore where you can put saved instance state. Added by stateFlowViewModel helpers which work like by stateViewModel but use a StateFlowStore . Added by Fragment/Activity.savedInstanceState(default) and by StateFlowStore.getData(default) and extension function which automatically uses a key based on the property name. SavedStateHandleStore now provides an alternative constructor with doesn\u2019t require a CoroutineScope and only has one-way MutableValueFlow -> LiveData sync (which covers the 99% use-case). 3.6.0 \u00b6 Added SuspendMutableValueFlow for values that must be mutated via a suspend fun. 3.5.0 \u00b6 The lambda function for WhileUsed now receives a WhileUsedReferenceToken which has a lazy scope attribute in case you need a CoroutineScope with the same lifetime as your WhileUsed value. Fixed withLoading behavior of first derived calculation. 3.4.0 \u00b6 Added buildOnViewModel which allows creating arbitrary objects living on an internally-created wrapper ViewModel. Added MutableStateFlow.replace and MutableValueFlow.replaceLocked helper functions for simplifying e.g. data class copy() based mutation. 3.3.0 \u00b6 Added NamespacedStateFlowStore . Added ReducingStateFlow . 3.2.1 \u00b6 Moved from JCenter to Maven Central ( JCenter is shutting down ). Make sure your repositories block looks like this: repositories { google () mavenCentral () // ... } 3.2.0 \u00b6 CoroutineTest now implements AttachedDisposables and disposes at the end of runBlockingTest . CoroutineTest provides collectFlow to easily collect a derived with WhileSubscribed() in background. 3.1.1 \u00b6 Fixed withErrorReporting to really accept a suspension function. 3.1.0 \u00b6 Added withErrorReporting to handle suspension functions and optional onError . Added EventNotifier.handleEvents helpers for Kotlin and Android. The Android version takes a LifecycleOwner . Added EventNotifierTest . 3.0.0 \u00b6 Breaking changes: IMPORTANT: In order to overcome a limitation, the flowTransformer argument of derived / coAutoRun / CoAutoRunner must now map over lambda functions and execute them. E.g.: mapLatest { it() } . Without the it() no value will ever be recomputed! The default flowTransformer has changed from { mapLatest { } } to { conflatedWorker() } . There is also latestWorker if you want the old behavior. The possible arguments to derived were changed a little bit in order to improve compatibility with WhileUsed . Either you must remove the started: SharingStarted argument or additionally pass an initial value. If you leave out the started argument derived behaves like before when passing Eagerly : the value is computed immediately and synchronously and you can\u2019t call suspend functions within the observer. Otherwise, you have to pass an initial value. In this case, derived is asynchronous and you can call suspend functions within the observer. The default value for started is now Eagerly because that has better safety guarantees. So, in most usages the whole argument can now be removed (except where you really need WhileSubscribed() , for example). Removed bindings because they turned out to not be useful enough. Resolver.track() now returns the AutoRunnerObservable instead of the underlyingObservable . Non-breaking changes: Added WhileUsed for reference-counted singletons that get garbage-collected when all consumers\u2019 CoroutineScope s end. Added conflatedWorker , latestWorker and debouncedWorker as simple flowTransformer s for the suspend-based derived / coAutoRun . Added conflatedMap helper for mapping first and last elements and - whenever possible - intermediate elements. Added simple ErrorEvents interface and withErrorReporting(eventNotifier) { ... } for easy error handling. MutableFlow.tryEmit now returns a Boolean . Legal change: Switched license to Apache 2.0. 2.0.4 \u00b6 Upgraded dependencies (coroutines 1.4.3, androidx.lifecycle 2.3.0, fragment-ktx 1.3.1) 2.0.2 \u00b6 Fixed BOM (reactivestate was missing). 2.0.0 \u00b6 Breaking changes: Moved all Android-related code to the com.ensody.reactivestate.android package to avoid method resolution ambiguity. Removed CoroutineScopeOwner (replaced by CoroutineLauncher ). Non-breaking changes: Added CoroutineLauncher interface to allow overriding how autoRun / derived launch their coroutines (e.g. to include custom error handling or a loading state). Added coAutoRun and CoAutoRunner and derived variants which take suspension functions and use mapLatest . 1.1.0 \u00b6 StateFlowStore.getData() now returns a MutableValueFlow 1.0.0 \u00b6 derived now takes a mandatory started: SharingStarted argument - similar to stateIn / shareIn ( WhileSubscribed() , Lazily , Eagerly , etc.) 0.15.4 \u00b6 Fixed CoroutineTest . 0.15.3 \u00b6 Added support for using CoroutineTest by delegation (preventing multiple inheritance situations). 0.15.2 \u00b6 Added buildViewModel and stateViewModel extension functions for Activity . 0.15.0 \u00b6 derived supports an optional lazy = true argument to observe lazily. Added a global dispatchers API for replacing Dispatchers ( Main , IO , etc.) in a way that allows switching to TestCoroutineDispatcher in unit tests. Added coroutine unit test helpers in the com.ensody.reactivestate:core-test module: CoroutineTest base class for tests that use coroutines. This sets up MainScope , dispatchers.io , etc. to use TestCoroutineDispatcher . CoroutineTestRule a test rule for setting up coroutines. CoroutineTestRuleOwner a helper interface in case you can\u2019t use CoroutineTest , but still want minimal boilerplate. Removed launchWhileStarted and launchWhileResumed . Added dependency-versions-bom platform project. You can now include the versions of all modules like this: dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:dependency-versions-bom:VERSION\" ) // Now you can leave out the version number from all other ReactiveState modules: implementation \"com.ensody.reactivestate:core\" // For Kotlin-only projects implementation \"com.ensody.reactivestate:reactivestate\" // For Android projects implementation \"com.ensody.reactivestate:core-test\" // Utils for unit tests that want to use coroutines } 0.14.0 \u00b6 Fixed MutableValueFlow.value assignment to have distinctUntilChanged behavior. This should provide the best of both worlds: emit / tryEmit / update always emit .value behaves exactly like with MutableStateFlow 0.13.0 \u00b6 After a long period of tuning the API and use at several companies this release introduces the hopefully last set of major breaking changes. This is the final migration to Flow -based APIs like StateFlow / SharedFlow / ValueFlow and removal of obsolete APIs. autoRun now auto-disposes in Activity.onDestroy / Fragment.onDestroyView , so usually it should be launched in Activity.onCreate() / Fragment.onCreateView() (previously onStart() ). It still automatically observes only between onStart() / onStop() . Removed MutableLiveDataNonNull and other non-null LiveData helpers. Use MutableStateFlow and MutableValueFlow instead. Added MutableValueFlow which implements MutableStateFlow , but doesn\u2019t have distinctUntilChanged behavior and offers an in-place update { it.attr = ... } method. This makes it safer and easier to use with mutable values. Removed DerivedLiveData . Use DerivedStateFlow / derived instead. Replaced workQueue with the much simpler EventNotifier which allows sending one-time events to the UI. Replaced Scoped with a simple CoroutineScopeOwner interface. Upgraded to Kotlin 1.4.10. 0.12.0 \u00b6 Breaking changes (migration to StateFlow ): derived now returns a StateFlow instead of a LiveData , so you can use derived in multiplatform code. LiveDataStore has been replaced with StateFlowStore , so you can write multiplatform code. InMemoryStore has been replaced with InMemoryStateFlowStore . SavedStateHandleStore now implements StateFlowStore and requires a CoroutineScope in addition to SavedStateHandle . State has been renamed to Scoped (more descriptive). Other changes: Added StateFlow -based API for bindings. The LiveData -based API is still available. 0.11.4 \u00b6 Switched to api instead of implementation for most dependencies. 0.11.3 \u00b6 Fixed edge case with autoRun on LiveData incorrectly ignoring the first notification. 0.11.2 \u00b6 Fixed release packaging of Android reactivestate package. 0.11 \u00b6 ATTENTION: There\u2019s a breaking change to support StateFlow . Added experimental StateFlow support to autoRun ( StateFlow was added in kotlinx-coroutines-core 1.3.6). Breaking change: Removed CoroutineContext.autoRun and suspend fun autoRun because proper StateFlow support requires access to a CoroutineScope . 0.10 \u00b6 Added thisWorkQueue helper for passing an arg via this . argWorkQueue now supports suspension functions. Added AttachedDisposables interface for objects that can clean up other disposables. AutoRunner now implements AttachedDisposables . Added OnDispose { ... } class for triggering a function when its dispose() method is called. Added onDestroyView { ... } , onDestroy , onCreate , onCreateView and their ...Once variants. Added validUntil for properties that are only valid during a lifecycle subset. Further documentation improvements. 0.9.1 \u00b6 This release introduces no code changes. Fixed release publication on jcenter. Minor documentation improvements. 0.9 \u00b6 ATTENTION: Due to the core & reactivestate module split you have to also add the core module to your dependencies as described in the installation instructions . This release splits the reactivestate module into a Kotlin module ( core ) and an Android module ( reactivestate ). The change is backwards-compatible unless you\u2019ve accessed BaseAutoRunner (very unlikely). Added State base class for separating business logic from ViewModel , making it easier to use in normal unit tests. Added argWorkQueue , arg-based consume and consumeConflated helpers for ViewModel -> UI event/notification use-case. Fixed one-level recursion when observing LiveData . Documentation improvements. 0.8 \u00b6 ATTENTION: This release comes with a few breaking changes. Bindings don\u2019t have value converters, anymore. Usually you need to store the raw field value and a separate conversion (if possible without errors), anyway. Use autoRun or derived to convert values. Added bindings for CompoundButton (replacing CheckBox bindings). AutoRunner \u2018s and autoRun \u2018s observer callback now receives the Resolver via this instead of as an argument (more consistent and compact code). You can write get(livedata) to retrieve a LiveData value. AutoRunner \u2018s and autoRun \u2018s onChange callback now receives the AutoRunner as its first argument. Improved AutoRunner \u2018s null handling of LiveData . Added onResume , onResumeOnce , onPause , onPauseOnce , launchWhileResumed lifecycle observers. Added Disposable.disposeOnCompletionOf(coroutineContext) extension methods. Added WorkQueue and helpers like conflatedWorkQueue for simpler communication between UI and ViewModel. Added unit tests. Added simple documentation with API reference. 0.5 \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#521","text":"Made Wrapped a Serializable on JVM. Added Serializable interface that maps to the JVM Serializable and is usable from commonMain .","title":"5.2.1"},{"location":"changelog/#520","text":"Extracted non-Android code into reactivestate-core(-test) modules, so you can use ReactiveState with minimal dependencies. Added MutableStateFlow.afterUpdate to complete the API introduced in version 5.1.0.","title":"5.2.0"},{"location":"changelog/#513","text":"Upgraded to Kotlin 1.7.21.","title":"5.1.3"},{"location":"changelog/#512","text":"Downgraded to Kotlin 1.7.20 because of huge compilation speed degradation on iOS targets and incompatibility with Compose.","title":"5.1.2"},{"location":"changelog/#511","text":"Improved Swift compatibility of eventNotifier by making the lambdas non- suspend .","title":"5.1.1"},{"location":"changelog/#510","text":"Added MutableStateFlow.beforeUpdate and MutableStateFlow.withSetter setter interceptors. Upgraded to Kotlin 1.8.0. Due to the deprecation of the old JS compiler in Kotlin 1.8.0 the code has switched to the IR compiler.","title":"5.1.0"},{"location":"changelog/#502","text":"Upgraded to Kotlin 1.7.20, kotlinx.coroutines 1.6.4, androidx.activity 1.6.0, androidx.fragment 1.5.3. Upgraded to Android SDK 33. The experimental reactivestate-compose module is not published in this release due to a Kotlin/Compose compiler bug.","title":"5.0.2"},{"location":"changelog/#501","text":"Adjusted EventNotifierTest / ReactiveStateTest to be consistent with the coroutines test lib behavior. You have to call runCurrent() to execute any coroutines launched from the ViewModel\u2019s init block.","title":"5.0.1"},{"location":"changelog/#500","text":"Upgraded to kotlinx.coroutines 1.6.1. You might need to adjust your unit tests to take behavioral differences into account. Upgraded to Jetpack Compose 1.1.1. Upgraded to Kotlin 1.6.20. CoroutineTest.runBlockingTest was deprecated and you should now use CoroutineTest.runTest . Similarly, testCoroutineScope => testScope and testCoroutineDispatcher => testDispatcher . Use CoroutineTest.testScope only for coroutines that will terminate. For ReactiveStateTest you should use CoroutineTest.mainScope which gets canceled at the end of each test run. Native targets are compiled using the experimental memory manager. The reactivestate-test module can now be used with all targets instead of just JVM. Added a few more targets like macosArm64 and iosSimulatorArm64. Moved get(LiveData) to the com.ensody.reactivestate package, so you don\u2019t need to think twice about where you want to import from.","title":"5.0.0"},{"location":"changelog/#470","text":"Added Throwable.throwIfFatal() , Throwable.isFatal() and runCatchingNonFatal to deal with fatal errors like CancellationException in a simpler and platform-specific way.","title":"4.7.0"},{"location":"changelog/#462","text":"Fixed derived not replaying the current value.","title":"4.6.2"},{"location":"changelog/#461","text":"Fixed derived and derivedWhileSubscribed bug when used with multiple collectors. Fixed derived with WhileSubscribed subscribe/unsubscribe/re-subscribe bug.","title":"4.6.1"},{"location":"changelog/#460","text":"Added derived and derivedWhileSubscribed variants which don\u2019t need a CoroutineScope , so you don\u2019t need to infect your business logic with scopes.","title":"4.6.0"},{"location":"changelog/#450","text":"Upgraded to Kotlin 1.6.10 and Jetpack Compose 1.1.0-rc01. Internal improvements.","title":"4.5.0"},{"location":"changelog/#440","text":"Added experimental Jetpack Compose support (currently Android-only). By adding com.ensody.reactivestate:reactivestate-compose to your dependencies and you can use the viewModel { MyViewModel() } and reactiveState { ... } Composable s.","title":"4.4.0"},{"location":"changelog/#432","text":"Fixed race condition with autoRun \u2018s observables being changed during run.","title":"4.3.2"},{"location":"changelog/#431","text":"Fixed race condition with derived where the observed StateFlow gets changed during first run.","title":"4.3.1"},{"location":"changelog/#430","text":"Added @DependencyAccessor annotation to ensure the DI pattern is respected instead of the service locator pattern.","title":"4.3.0"},{"location":"changelog/#421","text":"Fixed recursively changing the value of a MutableValueFlow from within the collect block (change->emit->change). Previously this could lead to a deadlock because the first change is still locking the MutableValueFLow .","title":"4.2.1"},{"location":"changelog/#420","text":"Added OnReactiveStateAttached interface to allow customizing by reactiveState behavior.","title":"4.2.0"},{"location":"changelog/#410","text":"Added MutableValueFlow<Int>.incrementFrom(flow: StateFlow<Int>) extension function to e.g. sum multiple loading states into one MutableValueFlow<Int> .","title":"4.1.0"},{"location":"changelog/#400","text":"This release adds support for Kotlin Multiplatform and introduces a multiplatform ReactiveState ViewModel. Breaking changes: The modules have been restructured and renamed: reactivestate-bom (previously dependency-versions-bom) reactivestate (previously core and reactivestate) reactivestate-test (previously core-test) CoroutineTestRule is now a simple class that you can either derive from or add as an attribute. CoroutineTest has become independent of JUnit and inherits from CoroutineTestRule . The coroutineTestRule attribute has been replaced with direct testCoroutineScope and testCoroutineDispatcher attributes inherited from the new CoroutineTestRule . The withLoading concept in autoRun , CoroutineLauncher etc. has become more flexible to allow tracking separate loading states. Removed ReducingStateFlow as part of the simplified loading state concept. Non-breaking changes: Added a multiplatform ViewModel ReactiveState (interface), BaseReactiveState (base class). This is actually a broader concept that can be used for any living object that can launch coroutines, automatically handles errors, triggers events, and tracks loading states. Added a multiplatform buildViewModel extension function for creating such a ViewModel on an Activity and Fragment. Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers: onCreate , onCreateView , onCreateViewOnce , onDestroyView , onDestroyViewOnce . MutableValueFlow.replaceLocked returns the previous value now. Known limitations which will be solved with later releases: On non-JVM platforms, dispatchers.io currently equals Dispatchers.Default . This primarily affects MutableValueFlow : Internally, all uses of the JVM-only synchronized have been replaced with a spinlock Mutex since they were only utilized for very tiny blocks of code which normally don\u2019t even have any parallel access. Be careful about doing too large computations in combination with highly concurrent updates via replaceLocked , though. Changelog of preview releases: 4.0.0-dev.4: Fixed build failures due to Jacoco integration. 4.0.0-dev.3: Removed ReducingStateFlow . Publish iOS/macOS builds. 4.0.0-dev.2: Improved automatic error catching for autoRun and derived . Fixes for lifecycle observers Removed LoadingStateTracker . Replaced CoroutineLauncher.isAnyLoading and generalLoading with a simple loading: MutableValueFlow<Int> . MutableValueFlow.replaceLocked returns the previous value now. MutableValueFlow.increment / decrement now have an optional amount argument to increment by more than 1. Also, they return the previous value. 4.0.0-dev.1: This preview release comes without macOS/iOS builds. A port of the CI pipeline is in progress.","title":"4.0.0"},{"location":"changelog/#390","text":"Added @ExperimentalReactiveStateApi annotation to mark experimental APIs. Explicitly marked SuspendMutableValueFlow as experimental and changed its constructor to take the default value instead of a delegating MutableValueFlow . Turned SuspendMutableValueFlow into an interface and constructor/factory function.","title":"3.9.0"},{"location":"changelog/#383","text":"Fixed argument inconsistency in SuspendMutableValueFlow.replace .","title":"3.8.3"},{"location":"changelog/#382","text":"Fixed state restoration with SavedStateHandleStore .","title":"3.8.2"},{"location":"changelog/#381","text":"Fixed support for nullable values in SavedStateHandleStore .","title":"3.8.1"},{"location":"changelog/#380","text":"Added by propertyName and by lazyProperty helpers simplifying ReadOnlyProperty .","title":"3.8.0"},{"location":"changelog/#370","text":"MutableValueFlow \u2018s constructor now optionally takes a setter lambda function which is executed before emitting a new value. This allows observing / reacting to changes without needing a CoroutineScope . Added val Fragment/Activity.savedInstanceState helper which gives you access to a StateFlowStore where you can put saved instance state. Added by stateFlowViewModel helpers which work like by stateViewModel but use a StateFlowStore . Added by Fragment/Activity.savedInstanceState(default) and by StateFlowStore.getData(default) and extension function which automatically uses a key based on the property name. SavedStateHandleStore now provides an alternative constructor with doesn\u2019t require a CoroutineScope and only has one-way MutableValueFlow -> LiveData sync (which covers the 99% use-case).","title":"3.7.0"},{"location":"changelog/#360","text":"Added SuspendMutableValueFlow for values that must be mutated via a suspend fun.","title":"3.6.0"},{"location":"changelog/#350","text":"The lambda function for WhileUsed now receives a WhileUsedReferenceToken which has a lazy scope attribute in case you need a CoroutineScope with the same lifetime as your WhileUsed value. Fixed withLoading behavior of first derived calculation.","title":"3.5.0"},{"location":"changelog/#340","text":"Added buildOnViewModel which allows creating arbitrary objects living on an internally-created wrapper ViewModel. Added MutableStateFlow.replace and MutableValueFlow.replaceLocked helper functions for simplifying e.g. data class copy() based mutation.","title":"3.4.0"},{"location":"changelog/#330","text":"Added NamespacedStateFlowStore . Added ReducingStateFlow .","title":"3.3.0"},{"location":"changelog/#321","text":"Moved from JCenter to Maven Central ( JCenter is shutting down ). Make sure your repositories block looks like this: repositories { google () mavenCentral () // ... }","title":"3.2.1"},{"location":"changelog/#320","text":"CoroutineTest now implements AttachedDisposables and disposes at the end of runBlockingTest . CoroutineTest provides collectFlow to easily collect a derived with WhileSubscribed() in background.","title":"3.2.0"},{"location":"changelog/#311","text":"Fixed withErrorReporting to really accept a suspension function.","title":"3.1.1"},{"location":"changelog/#310","text":"Added withErrorReporting to handle suspension functions and optional onError . Added EventNotifier.handleEvents helpers for Kotlin and Android. The Android version takes a LifecycleOwner . Added EventNotifierTest .","title":"3.1.0"},{"location":"changelog/#300","text":"Breaking changes: IMPORTANT: In order to overcome a limitation, the flowTransformer argument of derived / coAutoRun / CoAutoRunner must now map over lambda functions and execute them. E.g.: mapLatest { it() } . Without the it() no value will ever be recomputed! The default flowTransformer has changed from { mapLatest { } } to { conflatedWorker() } . There is also latestWorker if you want the old behavior. The possible arguments to derived were changed a little bit in order to improve compatibility with WhileUsed . Either you must remove the started: SharingStarted argument or additionally pass an initial value. If you leave out the started argument derived behaves like before when passing Eagerly : the value is computed immediately and synchronously and you can\u2019t call suspend functions within the observer. Otherwise, you have to pass an initial value. In this case, derived is asynchronous and you can call suspend functions within the observer. The default value for started is now Eagerly because that has better safety guarantees. So, in most usages the whole argument can now be removed (except where you really need WhileSubscribed() , for example). Removed bindings because they turned out to not be useful enough. Resolver.track() now returns the AutoRunnerObservable instead of the underlyingObservable . Non-breaking changes: Added WhileUsed for reference-counted singletons that get garbage-collected when all consumers\u2019 CoroutineScope s end. Added conflatedWorker , latestWorker and debouncedWorker as simple flowTransformer s for the suspend-based derived / coAutoRun . Added conflatedMap helper for mapping first and last elements and - whenever possible - intermediate elements. Added simple ErrorEvents interface and withErrorReporting(eventNotifier) { ... } for easy error handling. MutableFlow.tryEmit now returns a Boolean . Legal change: Switched license to Apache 2.0.","title":"3.0.0"},{"location":"changelog/#204","text":"Upgraded dependencies (coroutines 1.4.3, androidx.lifecycle 2.3.0, fragment-ktx 1.3.1)","title":"2.0.4"},{"location":"changelog/#202","text":"Fixed BOM (reactivestate was missing).","title":"2.0.2"},{"location":"changelog/#200","text":"Breaking changes: Moved all Android-related code to the com.ensody.reactivestate.android package to avoid method resolution ambiguity. Removed CoroutineScopeOwner (replaced by CoroutineLauncher ). Non-breaking changes: Added CoroutineLauncher interface to allow overriding how autoRun / derived launch their coroutines (e.g. to include custom error handling or a loading state). Added coAutoRun and CoAutoRunner and derived variants which take suspension functions and use mapLatest .","title":"2.0.0"},{"location":"changelog/#110","text":"StateFlowStore.getData() now returns a MutableValueFlow","title":"1.1.0"},{"location":"changelog/#100","text":"derived now takes a mandatory started: SharingStarted argument - similar to stateIn / shareIn ( WhileSubscribed() , Lazily , Eagerly , etc.)","title":"1.0.0"},{"location":"changelog/#0154","text":"Fixed CoroutineTest .","title":"0.15.4"},{"location":"changelog/#0153","text":"Added support for using CoroutineTest by delegation (preventing multiple inheritance situations).","title":"0.15.3"},{"location":"changelog/#0152","text":"Added buildViewModel and stateViewModel extension functions for Activity .","title":"0.15.2"},{"location":"changelog/#0150","text":"derived supports an optional lazy = true argument to observe lazily. Added a global dispatchers API for replacing Dispatchers ( Main , IO , etc.) in a way that allows switching to TestCoroutineDispatcher in unit tests. Added coroutine unit test helpers in the com.ensody.reactivestate:core-test module: CoroutineTest base class for tests that use coroutines. This sets up MainScope , dispatchers.io , etc. to use TestCoroutineDispatcher . CoroutineTestRule a test rule for setting up coroutines. CoroutineTestRuleOwner a helper interface in case you can\u2019t use CoroutineTest , but still want minimal boilerplate. Removed launchWhileStarted and launchWhileResumed . Added dependency-versions-bom platform project. You can now include the versions of all modules like this: dependencies { // Add the BOM using the desired ReactiveState version api platform ( \"com.ensody.reactivestate:dependency-versions-bom:VERSION\" ) // Now you can leave out the version number from all other ReactiveState modules: implementation \"com.ensody.reactivestate:core\" // For Kotlin-only projects implementation \"com.ensody.reactivestate:reactivestate\" // For Android projects implementation \"com.ensody.reactivestate:core-test\" // Utils for unit tests that want to use coroutines }","title":"0.15.0"},{"location":"changelog/#0140","text":"Fixed MutableValueFlow.value assignment to have distinctUntilChanged behavior. This should provide the best of both worlds: emit / tryEmit / update always emit .value behaves exactly like with MutableStateFlow","title":"0.14.0"},{"location":"changelog/#0130","text":"After a long period of tuning the API and use at several companies this release introduces the hopefully last set of major breaking changes. This is the final migration to Flow -based APIs like StateFlow / SharedFlow / ValueFlow and removal of obsolete APIs. autoRun now auto-disposes in Activity.onDestroy / Fragment.onDestroyView , so usually it should be launched in Activity.onCreate() / Fragment.onCreateView() (previously onStart() ). It still automatically observes only between onStart() / onStop() . Removed MutableLiveDataNonNull and other non-null LiveData helpers. Use MutableStateFlow and MutableValueFlow instead. Added MutableValueFlow which implements MutableStateFlow , but doesn\u2019t have distinctUntilChanged behavior and offers an in-place update { it.attr = ... } method. This makes it safer and easier to use with mutable values. Removed DerivedLiveData . Use DerivedStateFlow / derived instead. Replaced workQueue with the much simpler EventNotifier which allows sending one-time events to the UI. Replaced Scoped with a simple CoroutineScopeOwner interface. Upgraded to Kotlin 1.4.10.","title":"0.13.0"},{"location":"changelog/#0120","text":"Breaking changes (migration to StateFlow ): derived now returns a StateFlow instead of a LiveData , so you can use derived in multiplatform code. LiveDataStore has been replaced with StateFlowStore , so you can write multiplatform code. InMemoryStore has been replaced with InMemoryStateFlowStore . SavedStateHandleStore now implements StateFlowStore and requires a CoroutineScope in addition to SavedStateHandle . State has been renamed to Scoped (more descriptive). Other changes: Added StateFlow -based API for bindings. The LiveData -based API is still available.","title":"0.12.0"},{"location":"changelog/#0114","text":"Switched to api instead of implementation for most dependencies.","title":"0.11.4"},{"location":"changelog/#0113","text":"Fixed edge case with autoRun on LiveData incorrectly ignoring the first notification.","title":"0.11.3"},{"location":"changelog/#0112","text":"Fixed release packaging of Android reactivestate package.","title":"0.11.2"},{"location":"changelog/#011","text":"ATTENTION: There\u2019s a breaking change to support StateFlow . Added experimental StateFlow support to autoRun ( StateFlow was added in kotlinx-coroutines-core 1.3.6). Breaking change: Removed CoroutineContext.autoRun and suspend fun autoRun because proper StateFlow support requires access to a CoroutineScope .","title":"0.11"},{"location":"changelog/#010","text":"Added thisWorkQueue helper for passing an arg via this . argWorkQueue now supports suspension functions. Added AttachedDisposables interface for objects that can clean up other disposables. AutoRunner now implements AttachedDisposables . Added OnDispose { ... } class for triggering a function when its dispose() method is called. Added onDestroyView { ... } , onDestroy , onCreate , onCreateView and their ...Once variants. Added validUntil for properties that are only valid during a lifecycle subset. Further documentation improvements.","title":"0.10"},{"location":"changelog/#091","text":"This release introduces no code changes. Fixed release publication on jcenter. Minor documentation improvements.","title":"0.9.1"},{"location":"changelog/#09","text":"ATTENTION: Due to the core & reactivestate module split you have to also add the core module to your dependencies as described in the installation instructions . This release splits the reactivestate module into a Kotlin module ( core ) and an Android module ( reactivestate ). The change is backwards-compatible unless you\u2019ve accessed BaseAutoRunner (very unlikely). Added State base class for separating business logic from ViewModel , making it easier to use in normal unit tests. Added argWorkQueue , arg-based consume and consumeConflated helpers for ViewModel -> UI event/notification use-case. Fixed one-level recursion when observing LiveData . Documentation improvements.","title":"0.9"},{"location":"changelog/#08","text":"ATTENTION: This release comes with a few breaking changes. Bindings don\u2019t have value converters, anymore. Usually you need to store the raw field value and a separate conversion (if possible without errors), anyway. Use autoRun or derived to convert values. Added bindings for CompoundButton (replacing CheckBox bindings). AutoRunner \u2018s and autoRun \u2018s observer callback now receives the Resolver via this instead of as an argument (more consistent and compact code). You can write get(livedata) to retrieve a LiveData value. AutoRunner \u2018s and autoRun \u2018s onChange callback now receives the AutoRunner as its first argument. Improved AutoRunner \u2018s null handling of LiveData . Added onResume , onResumeOnce , onPause , onPauseOnce , launchWhileResumed lifecycle observers. Added Disposable.disposeOnCompletionOf(coroutineContext) extension methods. Added WorkQueue and helpers like conflatedWorkQueue for simpler communication between UI and ViewModel. Added unit tests. Added simple documentation with API reference.","title":"0.8"},{"location":"changelog/#05","text":"Initial release.","title":"0.5"},{"location":"demand-driven-programming/","text":"Demand-driven programming \u00b6 Demand-driven means that expensive resources are automatically (on-demand) only allocated as long as they\u2019re needed and then freed when not needed. This also includes computations which should only happen when they\u2019re needed. For example, by lazy is not demand-driven because it only allocates resources on first use, but never deallocates. However, stateIn together with WhileSubscribed allows creating a demand-driven StateFlow that might e.g. communicate with a backend via a WebSocket (let\u2019s say a news ticker). Normally you want to only keep the connection open as long as there is some UI that displays the data. Once the user logs out or switches to some other screen or just locks his screen you want to close the connection. The point of being demand-driven is to make this automatic, so your code becomes 100% robust and simple, no matter in which way you change your UI. You should never have to plaster your code with explicit open() and close() logic everywhere because in practice this \u201cimperative\u201d logic leads to bugs. Imagine the a new requirement where you want to show the news widget in a few more screens, so now the connection needs to be kept open across some screens, but on others it can be closed. The way to model this problem is that some screens \u201cdemand\u201d the news ticker. In other words, they have a dependency on the news ticker. News ticker example \u00b6 Imagine you want to show the breaking news only, but the backend only provides a list of all latest news. We have to filter the breaking news from that list, but all of that should only happen while the screen is visible. If the user locks the screen or switches the app the connection should stop. class NewsTicker ( scope : CoroutineScope ) { val latestNews : StateFlow < List < News >> = channelFlow { // connect to backend, watch for changes and send() latest news, // and close the connection when the flow is cancelled }. stateIn ( initial = emptyList (), started = WhileSubscribed ()) } // A demand-driven singleton which you can put into your DI val newsTicker = WhileUsed { // it.scope is a MainScope that exists only as long someone depends on newsTicker // and is cancelled once it's not needed anymore. NewsTicker ( it . scope ) } val breakingNews : StateFlow < List < News >> = derived ( initial = emptyList (), started = WhileSubscribed ()) { get ( get ( newsTicker ). latestNews ) . filter { it . isBreakingNews } } class NewsScreen : Fragment () { override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // autoRun only collects in >= STARTED state. // When the user e.g. locks the screen or switches to some other app, // it cancels collecting because the state is < STARTED. autoRun { updateScreen ( get ( breakingNews )) } } fun updateScreen ( news : List < News > ) { // ... } } As you can see, some of this depends on Kotlin\u2019s WhileSubscribed() . WhileUsed allows you to create an on-demand computed singleton that gets disposed as soon as nobody is using it, anymore. Here we\u2019re applying it to only create the NewsTicker object as long as it\u2019s needed. Internally, WhileUsed is tracking the number of reference, so once that \u201creference count\u201d goes back to count == 0 it can destroy its value and CoroutineScope . As an alternative to the autoRun / derived based tracking, you can also use a CoroutineScope to track the dependency lifetime: // This holds the reference until coroutineScope is cancelled. // Note: it's lowercase newsTicker, so we're calling the WhileUsed object here. val newsTickerInstance = newsTicker ( coroutineScope ) If even this doesn\u2019t work for you, there are other alternatives like manual reference count tracking or passing a DisposableGroup .","title":"Demand-driven programming"},{"location":"demand-driven-programming/#demand-driven-programming","text":"Demand-driven means that expensive resources are automatically (on-demand) only allocated as long as they\u2019re needed and then freed when not needed. This also includes computations which should only happen when they\u2019re needed. For example, by lazy is not demand-driven because it only allocates resources on first use, but never deallocates. However, stateIn together with WhileSubscribed allows creating a demand-driven StateFlow that might e.g. communicate with a backend via a WebSocket (let\u2019s say a news ticker). Normally you want to only keep the connection open as long as there is some UI that displays the data. Once the user logs out or switches to some other screen or just locks his screen you want to close the connection. The point of being demand-driven is to make this automatic, so your code becomes 100% robust and simple, no matter in which way you change your UI. You should never have to plaster your code with explicit open() and close() logic everywhere because in practice this \u201cimperative\u201d logic leads to bugs. Imagine the a new requirement where you want to show the news widget in a few more screens, so now the connection needs to be kept open across some screens, but on others it can be closed. The way to model this problem is that some screens \u201cdemand\u201d the news ticker. In other words, they have a dependency on the news ticker.","title":"Demand-driven programming"},{"location":"demand-driven-programming/#news-ticker-example","text":"Imagine you want to show the breaking news only, but the backend only provides a list of all latest news. We have to filter the breaking news from that list, but all of that should only happen while the screen is visible. If the user locks the screen or switches the app the connection should stop. class NewsTicker ( scope : CoroutineScope ) { val latestNews : StateFlow < List < News >> = channelFlow { // connect to backend, watch for changes and send() latest news, // and close the connection when the flow is cancelled }. stateIn ( initial = emptyList (), started = WhileSubscribed ()) } // A demand-driven singleton which you can put into your DI val newsTicker = WhileUsed { // it.scope is a MainScope that exists only as long someone depends on newsTicker // and is cancelled once it's not needed anymore. NewsTicker ( it . scope ) } val breakingNews : StateFlow < List < News >> = derived ( initial = emptyList (), started = WhileSubscribed ()) { get ( get ( newsTicker ). latestNews ) . filter { it . isBreakingNews } } class NewsScreen : Fragment () { override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // autoRun only collects in >= STARTED state. // When the user e.g. locks the screen or switches to some other app, // it cancels collecting because the state is < STARTED. autoRun { updateScreen ( get ( breakingNews )) } } fun updateScreen ( news : List < News > ) { // ... } } As you can see, some of this depends on Kotlin\u2019s WhileSubscribed() . WhileUsed allows you to create an on-demand computed singleton that gets disposed as soon as nobody is using it, anymore. Here we\u2019re applying it to only create the NewsTicker object as long as it\u2019s needed. Internally, WhileUsed is tracking the number of reference, so once that \u201creference count\u201d goes back to count == 0 it can destroy its value and CoroutineScope . As an alternative to the autoRun / derived based tracking, you can also use a CoroutineScope to track the dependency lifetime: // This holds the reference until coroutineScope is cancelled. // Note: it's lowercase newsTicker, so we're calling the WhileUsed object here. val newsTickerInstance = newsTicker ( coroutineScope ) If even this doesn\u2019t work for you, there are other alternatives like manual reference count tracking or passing a DisposableGroup .","title":"News ticker example"},{"location":"error-handling/","text":"Error handling \u00b6 ErrorEvents \u00b6 This library provides a simple base events interface that is used in several places for error handling called ErrorEvents . Here\u2019s the whole implementation interface ErrorEvents { fun onError ( error : Throwable ) } Some of the functionality requires that you implement this interface. EventNotifier \u00b6 Your ViewModels and other classes that can launch their own coroutines somehow have to communicate errors to the UI (or higher-level layers in general). Note: This section only discusses the error-specific aspect of EventNotifier . See Event handling for more general usage of EventNotifier . Imagine this in your business logic or ViewModel: coroutineScope . launch { // someSuspendFun can throw an exception someSuspendFun () } If someSuspendFun() throws an exception, how will you let the user know that there is an error? You need an event queue/dispatcher that is processed by the UI. That\u2019s what EventNotifier is. val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { try { someSuspendFun () } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { // This sends the event via eventNotifier eventNotifier { onError ( e ) } } } } You can simplify that code by using withErrorReporting : val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { withErrorReporting ( eventNotifier ) { someSuspendFun () } } } BaseReactiveState \u00b6 The multiplatform ViewModel base class BaseReactiveState already provides an eventNotifier and a launch function that catches exceptions: class MyViewModel ( scope : CoroutineScope ) : BaseReactiveState < ErrorEvents > ( scope ) { init { launch { // ...code block... } } } This will automatically catch exceptions and trigger eventNotifier { onError(throwable) } . See Multiplatform ViewModels for more details.","title":"Error handling"},{"location":"error-handling/#error-handling","text":"","title":"Error handling"},{"location":"error-handling/#errorevents","text":"This library provides a simple base events interface that is used in several places for error handling called ErrorEvents . Here\u2019s the whole implementation interface ErrorEvents { fun onError ( error : Throwable ) } Some of the functionality requires that you implement this interface.","title":"ErrorEvents"},{"location":"error-handling/#eventnotifier","text":"Your ViewModels and other classes that can launch their own coroutines somehow have to communicate errors to the UI (or higher-level layers in general). Note: This section only discusses the error-specific aspect of EventNotifier . See Event handling for more general usage of EventNotifier . Imagine this in your business logic or ViewModel: coroutineScope . launch { // someSuspendFun can throw an exception someSuspendFun () } If someSuspendFun() throws an exception, how will you let the user know that there is an error? You need an event queue/dispatcher that is processed by the UI. That\u2019s what EventNotifier is. val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { try { someSuspendFun () } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { // This sends the event via eventNotifier eventNotifier { onError ( e ) } } } } You can simplify that code by using withErrorReporting : val eventNotifier = EventNotifier < ErrorEvents > () fun doSomething () { coroutineScope . launch { withErrorReporting ( eventNotifier ) { someSuspendFun () } } }","title":"EventNotifier"},{"location":"error-handling/#basereactivestate","text":"The multiplatform ViewModel base class BaseReactiveState already provides an eventNotifier and a launch function that catches exceptions: class MyViewModel ( scope : CoroutineScope ) : BaseReactiveState < ErrorEvents > ( scope ) { init { launch { // ...code block... } } } This will automatically catch exceptions and trigger eventNotifier { onError(throwable) } . See Multiplatform ViewModels for more details.","title":"BaseReactiveState"},{"location":"event-handling/","text":"Event handling \u00b6 Events \u00b6 Events are modeled as simple interfaces where each event is a method: // The ErrorEvents interface is already part of this library interface ErrorEvents { // The onError event which contains the original exception fun onError ( error : Throwable ) } // Now a custom event type interface FooEvents { // the onFoo event which contains a \"name\" argument fun onFoo ( name : String ) // the onOtherFoo event fun onOtherFoo () } // You can combine multiple events easily via multiple inheritance interface CombinedEvents : FooEvents , ErrorEvents // And of course you can also add more events interface CombinedAndCustomEvents : FooEvents , ErrorEvents { fun onCustomEvent () } The last two examples show why events should be modeled as normal interfaces instead of sealed classes/interfaces. With normal interfaces you can combine multiple event types very easily (even events defined outside of the current module). In the next section we\u2019ll take a look at how those events can be triggered. Also see Error handling for details on our ErrorEvents interface which is used in several places in this library. EventNotifier \u00b6 The EventNotifier class is an event queue on which you can emit events and some other part of your code can collect the events. The EventNotifier is actually a Channel wrapped in a Flow interface. Events are buffered until someone collects them. This is important because you never want to lose events. In contrast, a SharedFlow is lossy - which is often not what you want. Example how to emit events: // This EventNotifier can emit any events contained in CombinedEvents val eventNotifier = EventNotifier < CombinedEvents > () fun doSomething () { // Explicit version eventNotifier . tryEmit { onFoo ( \"Slim Shady\" ) } // Or the recommended, shorter version eventNotifier { onFoo ( \"Slim Shady\" ) } eventNotifier { onOtherFoo ( e ) } try { // ... } catch ( e : Throwable ) { eventNotifier { onError ( e ) } } } Example how you\u2019d collect events: // The event listener has to implement the respective events interface(s) class MyEventListener ( scope : CoroutineScope ) : CombinedEvents { init { scope . launch { eventNotifier . handleEvents ( this @MyEventListener ) } } override fun onFoo ( name : String ) { // The onFoo event got triggered. } override fun onError ( error : Throwable ) { // The onError event got triggered. If MyEventListener is some UI screen // you'd probably show an error dialog here. } // ... } Note: The multiplatform ViewModel BaseReactiveState already provides a built-in EventNotifier .","title":"Event handling"},{"location":"event-handling/#event-handling","text":"","title":"Event handling"},{"location":"event-handling/#events","text":"Events are modeled as simple interfaces where each event is a method: // The ErrorEvents interface is already part of this library interface ErrorEvents { // The onError event which contains the original exception fun onError ( error : Throwable ) } // Now a custom event type interface FooEvents { // the onFoo event which contains a \"name\" argument fun onFoo ( name : String ) // the onOtherFoo event fun onOtherFoo () } // You can combine multiple events easily via multiple inheritance interface CombinedEvents : FooEvents , ErrorEvents // And of course you can also add more events interface CombinedAndCustomEvents : FooEvents , ErrorEvents { fun onCustomEvent () } The last two examples show why events should be modeled as normal interfaces instead of sealed classes/interfaces. With normal interfaces you can combine multiple event types very easily (even events defined outside of the current module). In the next section we\u2019ll take a look at how those events can be triggered. Also see Error handling for details on our ErrorEvents interface which is used in several places in this library.","title":"Events"},{"location":"event-handling/#eventnotifier","text":"The EventNotifier class is an event queue on which you can emit events and some other part of your code can collect the events. The EventNotifier is actually a Channel wrapped in a Flow interface. Events are buffered until someone collects them. This is important because you never want to lose events. In contrast, a SharedFlow is lossy - which is often not what you want. Example how to emit events: // This EventNotifier can emit any events contained in CombinedEvents val eventNotifier = EventNotifier < CombinedEvents > () fun doSomething () { // Explicit version eventNotifier . tryEmit { onFoo ( \"Slim Shady\" ) } // Or the recommended, shorter version eventNotifier { onFoo ( \"Slim Shady\" ) } eventNotifier { onOtherFoo ( e ) } try { // ... } catch ( e : Throwable ) { eventNotifier { onError ( e ) } } } Example how you\u2019d collect events: // The event listener has to implement the respective events interface(s) class MyEventListener ( scope : CoroutineScope ) : CombinedEvents { init { scope . launch { eventNotifier . handleEvents ( this @MyEventListener ) } } override fun onFoo ( name : String ) { // The onFoo event got triggered. } override fun onError ( error : Throwable ) { // The onError event got triggered. If MyEventListener is some UI screen // you'd probably show an error dialog here. } // ... } Note: The multiplatform ViewModel BaseReactiveState already provides a built-in EventNotifier .","title":"EventNotifier"},{"location":"example-guess-the-number/","text":"Example: Guess the number \u00b6 Let\u2019s pretend we play the game \u201cguess the correct number\u201d where we can increment a number and submit it to the backend which then tells us whether we guessed correctly. The following is a short example based on a subset of the principles: a multiplatform ViewModel via BaseReactiveState (you can alternatively use the ReactiveState interface) event handling via BaseReactiveState.eventNotifier automatic error catching via BaseReactiveState.launch lifecycle aware Android UI via autoRun and by reactiveState (which observes BaseReactiveState.eventNotifier ) state restoration via StateFlowStore The most important missing bits: reactive StateFlow s via derived unit tests Note: You can alternatively use an Android ViewModel and/or combine only the features you prefer to use. Here\u2019s the sample code with a MainViewModel which triggers MainEvents that are handled by a MainScreen : // ErrorEvents provides just one core event: onError(error: Throwable) interface MainEvents : ErrorEvents { fun onCorrectNumberGuessed ( message : String ) } class MainViewModel ( scope : CoroutineScope , store : StateFlowStore , ) : BaseReactiveState < MainEvents > ( scope ) { // On state restoration, getData() will prefill the StateFlow with // the previous value. val lastMessage : StateFlow < String? > by store . getData ( null ) // That's the currently guessed number val number = MutableStateFlow ( 0 ) fun increment () { number . value += 1 } fun checkNumber () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and triggers ErrorEvents.onError(throwable) // using an event queue accessible via BaseReactiveState.eventNotifier. launch { val successMessage : String? = backend . submitNumber ( number . value ) // Persist the last message for state restoration lastMessage . value = successMessage if ( successMessage != null ) { // Yay, we have guessed correctly! We should show a \"success\" dialog. // Since the dialog must be shown exactly once (even on UI recreation // or state restoration), we communicate the result via an event. // The code block passed to eventNotifier will be executed on the // MainScreen/Fragment in the >= STARTED state (it's lifecycle aware). eventNotifier { onCorrectNumberGuessed ( successMessage ) } } } } } // Now some Android-specific code for the main screen (hopefully with Jetpack Compose // the screen code will also become multiplatform someday) // The Fragment has to implement its ViewModel's events interface (MainEvents). class MainScreen : Fragment (), MainEvents { // Attaches a multiplatform ViewModel (a ReactiveState instance) to the fragment. // Within the `by reactiveState` block you have access to scope and stateFlowStore // which are taken from an internally created Android ViewModel that hosts the // ReactiveState instance. // The stateFlowStore is backed by a Android's SavedStateHandle (the official way to // deal with saved instance state at the ViewModel layer). // Finally, `by beactiveState` automatically processes MainViewModel.eventNotifier // within the >= STARTED state, as promised in the comment above. private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // Let's use Android view bindings private lateinit var binding : MainViewBinding override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // Let's imagine we have a button to increment the current number binding . incrementButton . setOnClickListener { viewModel . increment () } // And another button to check if the current number is correct binding . checkNumberButton . setOnClickListener { viewModel . checkNumber () } // With autoRun you can keep the UI in sync with one or more StateFlows. // The get() call retrieves the StateFlow.value and tells autoRun to re-execute // the code block whenever the accessed StateFlow is changed. // Here we want the info text to always show the current number. autoRun { binding . infoTextView . text = \"Your current guess: ${ get ( viewModel . number ) } \" } // Once we've found the correct number we want to disable the // \"increment\" and \"check number\" buttons because the game is over. // Also, if we're currently doing a request we want to disable the buttons, too. autoRun { // Here we're watching multiple StateFlows at the same time. // BaseReactiveState.loading is a StateFlow<Int> tracking the number of // currently running coroutines that were started via BaseReactiveState.launch. // This is just the simplest possible example. // Instead of using `loading` you can also distinguish between different // loading states if you want. val buttonsEnabled = get ( viewModel . lastMessage ) == null && get ( viewModel . loading ) == 0 binding . incrementButton . isEnabled = buttonsEnabled binding . checkNumberButton . isEnabled = buttonsEnabled } // You'd usually also observe viewModel.loading (or other loading states) to // show a loading indicator, but let's keep this example small... } override fun onCorrectNumberGuessed ( message : String ) { // Show a nice dialog, congratulating the user } override fun onError ( error : Throwable ) { // This event is triggered if any exception is uncaught in the ViewModel. // Usually you'd show an error dialog here. } } All of this code is lifecycle aware, only executing in the >= STARTED state. You don\u2019t need to plaster all your code with copy-pasted try-catch logic. Most of the time you can deal with errors in onError() .","title":"Example: Guess the number"},{"location":"example-guess-the-number/#example-guess-the-number","text":"Let\u2019s pretend we play the game \u201cguess the correct number\u201d where we can increment a number and submit it to the backend which then tells us whether we guessed correctly. The following is a short example based on a subset of the principles: a multiplatform ViewModel via BaseReactiveState (you can alternatively use the ReactiveState interface) event handling via BaseReactiveState.eventNotifier automatic error catching via BaseReactiveState.launch lifecycle aware Android UI via autoRun and by reactiveState (which observes BaseReactiveState.eventNotifier ) state restoration via StateFlowStore The most important missing bits: reactive StateFlow s via derived unit tests Note: You can alternatively use an Android ViewModel and/or combine only the features you prefer to use. Here\u2019s the sample code with a MainViewModel which triggers MainEvents that are handled by a MainScreen : // ErrorEvents provides just one core event: onError(error: Throwable) interface MainEvents : ErrorEvents { fun onCorrectNumberGuessed ( message : String ) } class MainViewModel ( scope : CoroutineScope , store : StateFlowStore , ) : BaseReactiveState < MainEvents > ( scope ) { // On state restoration, getData() will prefill the StateFlow with // the previous value. val lastMessage : StateFlow < String? > by store . getData ( null ) // That's the currently guessed number val number = MutableStateFlow ( 0 ) fun increment () { number . value += 1 } fun checkNumber () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and triggers ErrorEvents.onError(throwable) // using an event queue accessible via BaseReactiveState.eventNotifier. launch { val successMessage : String? = backend . submitNumber ( number . value ) // Persist the last message for state restoration lastMessage . value = successMessage if ( successMessage != null ) { // Yay, we have guessed correctly! We should show a \"success\" dialog. // Since the dialog must be shown exactly once (even on UI recreation // or state restoration), we communicate the result via an event. // The code block passed to eventNotifier will be executed on the // MainScreen/Fragment in the >= STARTED state (it's lifecycle aware). eventNotifier { onCorrectNumberGuessed ( successMessage ) } } } } } // Now some Android-specific code for the main screen (hopefully with Jetpack Compose // the screen code will also become multiplatform someday) // The Fragment has to implement its ViewModel's events interface (MainEvents). class MainScreen : Fragment (), MainEvents { // Attaches a multiplatform ViewModel (a ReactiveState instance) to the fragment. // Within the `by reactiveState` block you have access to scope and stateFlowStore // which are taken from an internally created Android ViewModel that hosts the // ReactiveState instance. // The stateFlowStore is backed by a Android's SavedStateHandle (the official way to // deal with saved instance state at the ViewModel layer). // Finally, `by beactiveState` automatically processes MainViewModel.eventNotifier // within the >= STARTED state, as promised in the comment above. private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // Let's use Android view bindings private lateinit var binding : MainViewBinding override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) // Let's imagine we have a button to increment the current number binding . incrementButton . setOnClickListener { viewModel . increment () } // And another button to check if the current number is correct binding . checkNumberButton . setOnClickListener { viewModel . checkNumber () } // With autoRun you can keep the UI in sync with one or more StateFlows. // The get() call retrieves the StateFlow.value and tells autoRun to re-execute // the code block whenever the accessed StateFlow is changed. // Here we want the info text to always show the current number. autoRun { binding . infoTextView . text = \"Your current guess: ${ get ( viewModel . number ) } \" } // Once we've found the correct number we want to disable the // \"increment\" and \"check number\" buttons because the game is over. // Also, if we're currently doing a request we want to disable the buttons, too. autoRun { // Here we're watching multiple StateFlows at the same time. // BaseReactiveState.loading is a StateFlow<Int> tracking the number of // currently running coroutines that were started via BaseReactiveState.launch. // This is just the simplest possible example. // Instead of using `loading` you can also distinguish between different // loading states if you want. val buttonsEnabled = get ( viewModel . lastMessage ) == null && get ( viewModel . loading ) == 0 binding . incrementButton . isEnabled = buttonsEnabled binding . checkNumberButton . isEnabled = buttonsEnabled } // You'd usually also observe viewModel.loading (or other loading states) to // show a loading indicator, but let's keep this example small... } override fun onCorrectNumberGuessed ( message : String ) { // Show a nice dialog, congratulating the user } override fun onError ( error : Throwable ) { // This event is triggered if any exception is uncaught in the ViewModel. // Usually you'd show an error dialog here. } } All of this code is lifecycle aware, only executing in the >= STARTED state. You don\u2019t need to plaster all your code with copy-pasted try-catch logic. Most of the time you can deal with errors in onError() .","title":"Example: Guess the number"},{"location":"lifecycle-handling/","text":"Correct lifecycle handling \u00b6 interface MainEvents : ErrorEvents { fun showMessage ( message : String ) } // You can create a multiplatform ViewModel by deriving from // BaseReactiveState instead. More details below. class MainViewModel : ViewModel () { // This queue can be used to send events to the MainEvents in the STARTED // lifecycle state. Instead of boilerplaty event sealed classes we use a // simple MainEvents interface with methods. val eventNotifier = EventNotifier < MainEvents > () fun someAction () { viewModelScope . launch { val result = api . requestSomeAction () // Switch back to MainFragment (the latest visible instance). eventNotifier { // If the screen got rotated in the meantime, `this` would point // to the new MainFragment instance instead of the destroyed one // that did the initial `someAction` call above. showMessage ( result . someMessage ) } } } } class MainFragment : Fragment (), MainEvents { private val viewModel : MainViewModel by viewModels () init { // Execute the MainViewModel's events in the >=STARTED state to prevent crashes lifecycleScope . launchWhenStarted { viewModel . eventNotifier . collect { it () } } } // ... override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle? ): View { // ... // val button = ... button . setOnClickListener { viewModel . someAction () } // ... } fun showMessage ( message : String ) { // ... } } On Android, managing operations independently of the UI lifecycle (e.g. button click -> request -> UI rotated -> response -> UI update/navigation) is made unnecessarily difficult because Android can destroy your UI in the middle of an operation. To work around this, you\u2019ll usually launch a coroutine in ViewModel.viewModelScope and/or use a Channel to communicate between the ViewModel and the UI. In order to simplify this pattern, ReactiveState provides EventNotifier and the lower-level MutableFlow (which has buffered, exactly-once consumption semantics like a Channel ). Automatic cleanups based on lifecycle state \u00b6 Especially on Android it\u2019s very easy to shoot yourself in the foot and e.g. have a closure that keeps a reference to a destroyed Fragment or mistakenly execute code on a destroyed UI. ReactiveState provides a Disposable interface and most objects auto-dispose/terminate when a CoroutineScope or Android Lifecycle ends. You can also use disposable.disposeOnCompletionOf to auto-dispose your disposables. For more complex use-cases you can use DisposableGroup to combine (add/remove) multiple disposables into a single Disposable object. With extension functions like LifecycleOwner.onResume or LifecycleOwner.onStopOnce you can easily add long-running or one-time observers to a Lifecycle . These are the building blocks for your own lifecycle-aware components which can automatically clean up after themselves like LifecycleOwner.autoRun does. Finally, with validUntil() you can define properties that only exist during a certain lifecycle subset and are dereference their value outside of that lifecycle subset. This can get rid of the ugly boilerplate when working with view bindings, for example.","title":"Lifecycle handling"},{"location":"lifecycle-handling/#correct-lifecycle-handling","text":"interface MainEvents : ErrorEvents { fun showMessage ( message : String ) } // You can create a multiplatform ViewModel by deriving from // BaseReactiveState instead. More details below. class MainViewModel : ViewModel () { // This queue can be used to send events to the MainEvents in the STARTED // lifecycle state. Instead of boilerplaty event sealed classes we use a // simple MainEvents interface with methods. val eventNotifier = EventNotifier < MainEvents > () fun someAction () { viewModelScope . launch { val result = api . requestSomeAction () // Switch back to MainFragment (the latest visible instance). eventNotifier { // If the screen got rotated in the meantime, `this` would point // to the new MainFragment instance instead of the destroyed one // that did the initial `someAction` call above. showMessage ( result . someMessage ) } } } } class MainFragment : Fragment (), MainEvents { private val viewModel : MainViewModel by viewModels () init { // Execute the MainViewModel's events in the >=STARTED state to prevent crashes lifecycleScope . launchWhenStarted { viewModel . eventNotifier . collect { it () } } } // ... override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle? ): View { // ... // val button = ... button . setOnClickListener { viewModel . someAction () } // ... } fun showMessage ( message : String ) { // ... } } On Android, managing operations independently of the UI lifecycle (e.g. button click -> request -> UI rotated -> response -> UI update/navigation) is made unnecessarily difficult because Android can destroy your UI in the middle of an operation. To work around this, you\u2019ll usually launch a coroutine in ViewModel.viewModelScope and/or use a Channel to communicate between the ViewModel and the UI. In order to simplify this pattern, ReactiveState provides EventNotifier and the lower-level MutableFlow (which has buffered, exactly-once consumption semantics like a Channel ).","title":"Correct lifecycle handling"},{"location":"lifecycle-handling/#automatic-cleanups-based-on-lifecycle-state","text":"Especially on Android it\u2019s very easy to shoot yourself in the foot and e.g. have a closure that keeps a reference to a destroyed Fragment or mistakenly execute code on a destroyed UI. ReactiveState provides a Disposable interface and most objects auto-dispose/terminate when a CoroutineScope or Android Lifecycle ends. You can also use disposable.disposeOnCompletionOf to auto-dispose your disposables. For more complex use-cases you can use DisposableGroup to combine (add/remove) multiple disposables into a single Disposable object. With extension functions like LifecycleOwner.onResume or LifecycleOwner.onStopOnce you can easily add long-running or one-time observers to a Lifecycle . These are the building blocks for your own lifecycle-aware components which can automatically clean up after themselves like LifecycleOwner.autoRun does. Finally, with validUntil() you can define properties that only exist during a certain lifecycle subset and are dereference their value outside of that lifecycle subset. This can get rid of the ugly boilerplate when working with view bindings, for example.","title":"Automatic cleanups based on lifecycle state"},{"location":"multiplatform-viewmodels/","text":"Multiplatform ViewModels \u00b6 This library allows creating multiplatform ViewModels (inherited from BaseReactiveState ) and also provides a by reactiveState helper for attaching it to Android\u2019s Activity or Fragment with proper lifecycle handling. // This is a multiplatform \"ViewModel\". It doesn't inherit from Android's ViewModel // and doesn't depend on any Android code. // It can persist saved instance state via StateFlowStore. On iOS you could pass // e.g. an InMemoryStateFlowStore. // The base class for such ViewModels (and other \"living\" stateful objects) // is BaseReactiveState. You can alternatively use the ReactiveState interface // e.g. together with delegation. class MultiPlatformViewModel ( scope : CoroutineScope , // The StateFlowStore allows for state restoration (like onSaveInstanceState). // See next section for details. private val store : StateFlowStore , // For dependency injection private val dependency : SomeDependency , ) : BaseReactiveState < MyEvents > ( scope ) { val data = MutableStateFlow ( \"hello\" ) fun doSomething () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and forwards them to eventNotifier // via ErrorEvents.onError(throwable). launch { val result = callSomeSuspendFun () data . value = result // BaseReactiveState comes with a built-in eventNotifier eventNotifier { ... } } } } interface MyEvents : ErrorEvents { fun onResultReceived () } // Alternatively, this is an example in case you want to use Android-native ViewModels. // This ViewModel can persist state with SavedStateHandle (no more onSaveInstanceState() boilerplate) class StateViewModel ( val handle : SavedStateHandle , dependency : SomeDependency ) : ViewModel () { // ... } // Example integration with Android class MainFragment : Fragment () { // Attaches a multiplatform ViewModel (ReactiveState) to the fragment. // Within the \"by reactiveState\" block you have access to scope and stateFlowStore which are taken from an // internally created Android ViewModel that hosts the ReactiveState instance. private val multiPlatformViewModel by reactiveState { MultiPlatformViewModel ( scope , stateFlowStore , SomeDependency ()) } // Alternatively, for Android ViewModels there's stateViewModel and buildViewModel private val viewModel by stateViewModel { handle -> StateViewModel ( handle , SomeDependency ()) } // With buildOnViewModel you can create an arbitrary object that lives on an internally created wrapper ViewModel. // The \"by reactiveState\" helper is using this internally. private val someObjectOnAViewModel by buildOnViewModel { SomeObject () } } With buildOnViewModel you can create your fully custom ViewModel if prefer. However, BaseReactiveState comes with batteries included: event handling: Send one-time events to the UI via eventNotifier . error handling: launch catches all errors and forwards them to eventNotifier via ErrorEvents.onError(throwable) . lifecycle handling: With by reactiveState the eventNotifier is automatically observed in the >= STARTED state. loading indicators: launch automatically maintains a loading StateFlow , so you can show a loading indicator in the UI while the coroutine is running. This can use either the default loading or any custom MutableValueFlow<Int> , so you can distinguish different loading states, each having its own loading indicator in the UI. For Android, ReactiveState\u2019s by reactiveState , by buildViewModel , by stateViewModel , by buildOnViewModel , and similar extension functions allow creating a ViewModel by directly instantiating it. This results in more natural code and allows passing arguments to the ViewModel . Internally, these helper functions are simple wrappers around viewModels , ViewModelProvider.Factory and AbstractSavedStateViewModelFactory . They just reduce the amount of boilerplate for common use-cases. Launching coroutines \u00b6 To give you a deeper understanding what happens when you run: launch { // ...code block... } That piece of code is similar to writing this: scope . launch { loading . atomicIncrement () // however that works try { // ...code block... } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { eventNotifier . invoke { onError ( e ) } // explicitly writing invoke for clarity only } finally { loading . atomicDecrement () // however that works } } Customizing by reactiveState \u00b6 You can implement the OnReactiveStateAttached interface on your Fragment / Activity in order to customize the attachment procedure: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { val viewModel by reactiveState { ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { autoRun { setLoading ( get ( reactiveState . loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } } Alternatively, if you want to support multiple ViewModels and merge all their loadings states into one: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { // We'll merge the loading states of all ReactiveState instances into this one val loading = MutableValueFlow ( 0 ) val viewModel by reactiveState { ... } val viewModel2 by reactiveState { ... } val viewModel3 by reactiveState { ... } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) autoRun { setLoading ( get ( loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { lifecycleScope . launch { // Sum all loading states loading . incrementFrom ( reactiveState . loading ) } } }","title":"Multiplatform ViewModels"},{"location":"multiplatform-viewmodels/#multiplatform-viewmodels","text":"This library allows creating multiplatform ViewModels (inherited from BaseReactiveState ) and also provides a by reactiveState helper for attaching it to Android\u2019s Activity or Fragment with proper lifecycle handling. // This is a multiplatform \"ViewModel\". It doesn't inherit from Android's ViewModel // and doesn't depend on any Android code. // It can persist saved instance state via StateFlowStore. On iOS you could pass // e.g. an InMemoryStateFlowStore. // The base class for such ViewModels (and other \"living\" stateful objects) // is BaseReactiveState. You can alternatively use the ReactiveState interface // e.g. together with delegation. class MultiPlatformViewModel ( scope : CoroutineScope , // The StateFlowStore allows for state restoration (like onSaveInstanceState). // See next section for details. private val store : StateFlowStore , // For dependency injection private val dependency : SomeDependency , ) : BaseReactiveState < MyEvents > ( scope ) { val data = MutableStateFlow ( \"hello\" ) fun doSomething () { // In contrast to scope.launch, the BaseReactiveState.launch function // automatically catches exceptions and forwards them to eventNotifier // via ErrorEvents.onError(throwable). launch { val result = callSomeSuspendFun () data . value = result // BaseReactiveState comes with a built-in eventNotifier eventNotifier { ... } } } } interface MyEvents : ErrorEvents { fun onResultReceived () } // Alternatively, this is an example in case you want to use Android-native ViewModels. // This ViewModel can persist state with SavedStateHandle (no more onSaveInstanceState() boilerplate) class StateViewModel ( val handle : SavedStateHandle , dependency : SomeDependency ) : ViewModel () { // ... } // Example integration with Android class MainFragment : Fragment () { // Attaches a multiplatform ViewModel (ReactiveState) to the fragment. // Within the \"by reactiveState\" block you have access to scope and stateFlowStore which are taken from an // internally created Android ViewModel that hosts the ReactiveState instance. private val multiPlatformViewModel by reactiveState { MultiPlatformViewModel ( scope , stateFlowStore , SomeDependency ()) } // Alternatively, for Android ViewModels there's stateViewModel and buildViewModel private val viewModel by stateViewModel { handle -> StateViewModel ( handle , SomeDependency ()) } // With buildOnViewModel you can create an arbitrary object that lives on an internally created wrapper ViewModel. // The \"by reactiveState\" helper is using this internally. private val someObjectOnAViewModel by buildOnViewModel { SomeObject () } } With buildOnViewModel you can create your fully custom ViewModel if prefer. However, BaseReactiveState comes with batteries included: event handling: Send one-time events to the UI via eventNotifier . error handling: launch catches all errors and forwards them to eventNotifier via ErrorEvents.onError(throwable) . lifecycle handling: With by reactiveState the eventNotifier is automatically observed in the >= STARTED state. loading indicators: launch automatically maintains a loading StateFlow , so you can show a loading indicator in the UI while the coroutine is running. This can use either the default loading or any custom MutableValueFlow<Int> , so you can distinguish different loading states, each having its own loading indicator in the UI. For Android, ReactiveState\u2019s by reactiveState , by buildViewModel , by stateViewModel , by buildOnViewModel , and similar extension functions allow creating a ViewModel by directly instantiating it. This results in more natural code and allows passing arguments to the ViewModel . Internally, these helper functions are simple wrappers around viewModels , ViewModelProvider.Factory and AbstractSavedStateViewModelFactory . They just reduce the amount of boilerplate for common use-cases.","title":"Multiplatform ViewModels"},{"location":"multiplatform-viewmodels/#launching-coroutines","text":"To give you a deeper understanding what happens when you run: launch { // ...code block... } That piece of code is similar to writing this: scope . launch { loading . atomicIncrement () // however that works try { // ...code block... } catch ( e : CancellationException ) { throw e } catch ( e : Throwable ) { eventNotifier . invoke { onError ( e ) } // explicitly writing invoke for clarity only } finally { loading . atomicDecrement () // however that works } }","title":"Launching coroutines"},{"location":"multiplatform-viewmodels/#customizing-by-reactivestate","text":"You can implement the OnReactiveStateAttached interface on your Fragment / Activity in order to customize the attachment procedure: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { val viewModel by reactiveState { ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { autoRun { setLoading ( get ( reactiveState . loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } } Alternatively, if you want to support multiple ViewModels and merge all their loadings states into one: class MyFragment : Fragment (), OnReactiveStateAttached , ErrorEvents { // We'll merge the loading states of all ReactiveState instances into this one val loading = MutableValueFlow ( 0 ) val viewModel by reactiveState { ... } val viewModel2 by reactiveState { ... } val viewModel3 by reactiveState { ... } override fun onViewCreated ( view : View , savedInstanceState : Bundle?) { super . onViewCreated ( view , savedInstanceState ) autoRun { setLoading ( get ( loading ) > 0 ) } } fun setLoading ( isLoading : Boolean ) { // ... } override fun onReactiveStateAttached ( reactiveState : ReactiveState < out ErrorEvents > ) { lifecycleScope . launch { // Sum all loading states loading . incrementFrom ( reactiveState . loading ) } } }","title":"Customizing by reactiveState"},{"location":"mutablevalueflow/","text":"MutableValueFlow \u00b6 MutableValueFlow implements the same API as MutableStateFlow , but also provides some extras: The replaceLocked method allows safely replacing the current value under concurrent updates: // SubValue1 and SubValue2 are other data class data class SomeValue ( val subvalue1 : SubValue1 , val subvalue2 : SubValue2 , val isLoading : Boolean ) val valueFlow = MutableValueFlow ( SomeValue ( isLoading = false , /* ... */ )) valueFlow . replaceLocked { copy ( isLoading = true ) } // now valueFlow.value.isLoading is true Note: ReactiveState also provides an extension function, replace , which is defined on MutableStateFlow (and MutableValueFlow ) which does the same thing as replaceLocked , but without the concurrency safety. Additionally, MutableValueFlow has an update method for working with mutable values: // Now with var instead of val data class SomeValue ( var subvalue1 : SubValue1 , var subvalue2 : SubValue2 , var isLoading : Boolean ) // MutableValueFlow valueFlow . update { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } // versus MutableStateFlow stateFlow . value = flow . value . let { it . copy ( subvalue1 = it . subvalue1 . copy ( deepsubvalue = it . subvalue1 . deepsubvalue . copy ( somevalue = it . subvalue1 . deepsubvalue . somevalue + 3 ) ), subvalue2 = it . subvalue2 . copy ( state = SomeState . IN_PROGRESS ), isLoading = true , ) } If you work with immutable data classes then you might know this problem. You can make immutable data less painful with functional lenses (e.g. arrow Optics DSL and arrow Lens ), but that can still result in complicated and inefficient code. On the other hand, mutable data does allow to shoot yourself in the foot. So whether you want to use MutableValueFlow is a question of your architecture and code structure and the specific circumstances. Usually, reactive code consciously puts data into observables ( StateFlow s) in order to allow for reactivity. This results in a code structure where these StateFlow s are the primary hosts of each piece of data and the mutations are limited around each StateFlow or even around the observable database as the single source of truth. Under these circumstances it can be quite safe to work with mutable data and MutableValueFlow makes such use-cases simpler than MutableStateFlow . Sometimes you even have a mutable third-party object (e.g. AtomicInteger ) that you have to work with and StateFlow is impossible to use in those cases.","title":"MutableValueFlow"},{"location":"mutablevalueflow/#mutablevalueflow","text":"MutableValueFlow implements the same API as MutableStateFlow , but also provides some extras: The replaceLocked method allows safely replacing the current value under concurrent updates: // SubValue1 and SubValue2 are other data class data class SomeValue ( val subvalue1 : SubValue1 , val subvalue2 : SubValue2 , val isLoading : Boolean ) val valueFlow = MutableValueFlow ( SomeValue ( isLoading = false , /* ... */ )) valueFlow . replaceLocked { copy ( isLoading = true ) } // now valueFlow.value.isLoading is true Note: ReactiveState also provides an extension function, replace , which is defined on MutableStateFlow (and MutableValueFlow ) which does the same thing as replaceLocked , but without the concurrency safety. Additionally, MutableValueFlow has an update method for working with mutable values: // Now with var instead of val data class SomeValue ( var subvalue1 : SubValue1 , var subvalue2 : SubValue2 , var isLoading : Boolean ) // MutableValueFlow valueFlow . update { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } // versus MutableStateFlow stateFlow . value = flow . value . let { it . copy ( subvalue1 = it . subvalue1 . copy ( deepsubvalue = it . subvalue1 . deepsubvalue . copy ( somevalue = it . subvalue1 . deepsubvalue . somevalue + 3 ) ), subvalue2 = it . subvalue2 . copy ( state = SomeState . IN_PROGRESS ), isLoading = true , ) } If you work with immutable data classes then you might know this problem. You can make immutable data less painful with functional lenses (e.g. arrow Optics DSL and arrow Lens ), but that can still result in complicated and inefficient code. On the other hand, mutable data does allow to shoot yourself in the foot. So whether you want to use MutableValueFlow is a question of your architecture and code structure and the specific circumstances. Usually, reactive code consciously puts data into observables ( StateFlow s) in order to allow for reactivity. This results in a code structure where these StateFlow s are the primary hosts of each piece of data and the mutations are limited around each StateFlow or even around the observable database as the single source of truth. Under these circumstances it can be quite safe to work with mutable data and MutableValueFlow makes such use-cases simpler than MutableStateFlow . Sometimes you even have a mutable third-party object (e.g. AtomicInteger ) that you have to work with and StateFlow is impossible to use in those cases.","title":"MutableValueFlow"},{"location":"reactive-programming/","text":"Reactive programming \u00b6 val number = MutableStateFlow ( 0 ) // For complex apps you often need reactive StateFlows. That's what derived() is for. // This StateFlow is automatically recomputed whenever number's value is changed val doubledNumber : StateFlow < Int > = derived { 2 * get ( number ) } // Here we only compute the value while someone is subscribed to changes (autoRun, // derived or collect). This can be important for expensive computations/operations. val onDemandDoubledNumber = derived ( initial = 0 , started = WhileSubscribed ()) { // Note: you could even call suspension functions from within this block // to e.g. fetch something from the backend. 2 * get ( number ) } With autoRun (available on LifecycleOwner , ViewModel , CoroutineScope , etc.) you can observe and re-execute a function whenever any of the StateFlow or LiveData instances accessed by that function are modified. On Android you can use this to keeping the UI in sync with your ViewModel. Of course, you can also keep non-UI state in sync. Depending on the context in which autoRun is executed, this observer is automatically tied to a CoroutineScope (e.g. the ViewModel \u2018s viewModelScope ) or in case of a Fragment / Activity to the onStart() / onStop() lifecycle in order to prevent accidental crashes and unnecessary resource consumption. With derived you can construct new StateFlow s based on the autoRun principle. You can control when the calculation should run by passing Eagerly , Lazily or WhileSubscribed() , for example. Especially WhileSubscribed() is important for expensive computations. If you don\u2019t have access to a CoroutineScope you can use the non-suspend based derived and suspend-based derivedWhileSubscribed . However, in this case you can\u2019t use Eagerly / Lazily / etc. since that would prevent garbage collection. The non-suspend derived recomputes itself when accessing its .value and while someone is subscribed. The suspend-based derivedWhileSubscribed only recomputes while someone is subscribed. Since it might be important if you rely on side-effects (which is not a good idea anyway), it should be emphasized: Both of these CoroutineScope -less functions have in common that they won\u2019t do any recomputation if nobody is subscribed and nobody accesses .value . If you want the full Eager / Lazy behavior you need a CoroutineScope . Note that autoRun can be extended to support observables other than StateFlow , LiveData and WhileUsed . The simplicity advantage of autoRun / derived requires using StateFlow instead of Flow to avoid writing chains of combine , map , flatMapLatest , conflate , etc. Luckily, if you only have a Flow , you can use Flow.stateIn() to convert it to a StateFlow .","title":"Reactive programming"},{"location":"reactive-programming/#reactive-programming","text":"val number = MutableStateFlow ( 0 ) // For complex apps you often need reactive StateFlows. That's what derived() is for. // This StateFlow is automatically recomputed whenever number's value is changed val doubledNumber : StateFlow < Int > = derived { 2 * get ( number ) } // Here we only compute the value while someone is subscribed to changes (autoRun, // derived or collect). This can be important for expensive computations/operations. val onDemandDoubledNumber = derived ( initial = 0 , started = WhileSubscribed ()) { // Note: you could even call suspension functions from within this block // to e.g. fetch something from the backend. 2 * get ( number ) } With autoRun (available on LifecycleOwner , ViewModel , CoroutineScope , etc.) you can observe and re-execute a function whenever any of the StateFlow or LiveData instances accessed by that function are modified. On Android you can use this to keeping the UI in sync with your ViewModel. Of course, you can also keep non-UI state in sync. Depending on the context in which autoRun is executed, this observer is automatically tied to a CoroutineScope (e.g. the ViewModel \u2018s viewModelScope ) or in case of a Fragment / Activity to the onStart() / onStop() lifecycle in order to prevent accidental crashes and unnecessary resource consumption. With derived you can construct new StateFlow s based on the autoRun principle. You can control when the calculation should run by passing Eagerly , Lazily or WhileSubscribed() , for example. Especially WhileSubscribed() is important for expensive computations. If you don\u2019t have access to a CoroutineScope you can use the non-suspend based derived and suspend-based derivedWhileSubscribed . However, in this case you can\u2019t use Eagerly / Lazily / etc. since that would prevent garbage collection. The non-suspend derived recomputes itself when accessing its .value and while someone is subscribed. The suspend-based derivedWhileSubscribed only recomputes while someone is subscribed. Since it might be important if you rely on side-effects (which is not a good idea anyway), it should be emphasized: Both of these CoroutineScope -less functions have in common that they won\u2019t do any recomputation if nobody is subscribed and nobody accesses .value . If you want the full Eager / Lazy behavior you need a CoroutineScope . Note that autoRun can be extended to support observables other than StateFlow , LiveData and WhileUsed . The simplicity advantage of autoRun / derived requires using StateFlow instead of Flow to avoid writing chains of combine , map , flatMapLatest , conflate , etc. Luckily, if you only have a Flow , you can use Flow.stateIn() to convert it to a StateFlow .","title":"Reactive programming"},{"location":"state-restoration/","text":"State restoration \u00b6 // Multiplatform ViewModel class MainViewModel ( scope : CoroutineScope , store : StateFlowStore ) : BaseReactiveState < ErrorEvents > ( scope ) { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } // Android ViewModel class MainViewModel ( store : StateFlowStore ) : ViewModel () { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } A StateFlowStore provides a similar API to Android\u2019s SavedStateHandle , but based on StateFlow instead of LiveData . With InMemoryStateFlowStore you can do e.g. unit testing or abstract away platform differences in multiplatform projects. This is how you can create an Android ViewModel with a StateFlowStore : // Multiplatform ViewModel class MainFragment : Fragment () { private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // ... } // Android ViewModel class MainFragment : Fragment () { private val viewModel by stateFlowViewModel { MainViewModel ( stateFlowStore ) } // ... } Both by reactiveState and by stateFlowViewModel provide a stateFlowStore value within their lambda blocks.","title":"State restoration"},{"location":"state-restoration/#state-restoration","text":"// Multiplatform ViewModel class MainViewModel ( scope : CoroutineScope , store : StateFlowStore ) : BaseReactiveState < ErrorEvents > ( scope ) { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } // Android ViewModel class MainViewModel ( store : StateFlowStore ) : ViewModel () { val count : StateFlow < Int > = store . getData ( \"count\" , 0 ) } A StateFlowStore provides a similar API to Android\u2019s SavedStateHandle , but based on StateFlow instead of LiveData . With InMemoryStateFlowStore you can do e.g. unit testing or abstract away platform differences in multiplatform projects. This is how you can create an Android ViewModel with a StateFlowStore : // Multiplatform ViewModel class MainFragment : Fragment () { private val viewModel by reactiveState { MainViewModel ( scope , stateFlowStore ) } // ... } // Android ViewModel class MainFragment : Fragment () { private val viewModel by stateFlowViewModel { MainViewModel ( stateFlowStore ) } // ... } Both by reactiveState and by stateFlowViewModel provide a stateFlowStore value within their lambda blocks.","title":"State restoration"},{"location":"unit-testing-coroutines/","text":"Unit tests with coroutines \u00b6 The CoroutineTest base class provides some often useful helpers for working with coroutines. class MyTest : CoroutineTest () { // This works because MainScope/Dispatchers.Main is automatically set up correctly by CoroutineTest val viewModel = MyViewModel () // Let's use a mock to test the events emitted by MyViewModel val events : MyEvents = mock () @Before fun setup () { // You can access the TestCoroutineScope directly to launch some background processing. // In this case, let's process MyViewModel's events. testCoroutineScope . launch { viewModel . eventNotifier . collect { events . it () } } } @Test fun someTest () = runBlockingTest { viewModel . doSomething () advanceUntilIdle () verify ( events ). someEvent () } } This also sets up a global dispatchers variable which you can use in all of your code instead of passing a CoroutineDispatcher around as arguments: // Use this instead of Dispatchers.IO. In unit tests this will automatically use // the TestCoroutineDispatcher instead. Outside of unit tests it points to Dispatchers.IO. // You can also define your own overrides if you want. withContext ( dispatchers . io ) { // do some IO } If you can\u2019t derive from CoroutineTest directly (e.g. because you have some other base test class), you can alternatively use composition with the CoroutineTestRule : class MyTest { val rule = CoroutineTestRule () @Test fun someTest () = rule . runBlockingTest { // ... } }","title":"Unit testing coroutines"},{"location":"unit-testing-coroutines/#unit-tests-with-coroutines","text":"The CoroutineTest base class provides some often useful helpers for working with coroutines. class MyTest : CoroutineTest () { // This works because MainScope/Dispatchers.Main is automatically set up correctly by CoroutineTest val viewModel = MyViewModel () // Let's use a mock to test the events emitted by MyViewModel val events : MyEvents = mock () @Before fun setup () { // You can access the TestCoroutineScope directly to launch some background processing. // In this case, let's process MyViewModel's events. testCoroutineScope . launch { viewModel . eventNotifier . collect { events . it () } } } @Test fun someTest () = runBlockingTest { viewModel . doSomething () advanceUntilIdle () verify ( events ). someEvent () } } This also sets up a global dispatchers variable which you can use in all of your code instead of passing a CoroutineDispatcher around as arguments: // Use this instead of Dispatchers.IO. In unit tests this will automatically use // the TestCoroutineDispatcher instead. Outside of unit tests it points to Dispatchers.IO. // You can also define your own overrides if you want. withContext ( dispatchers . io ) { // do some IO } If you can\u2019t derive from CoroutineTest directly (e.g. because you have some other base test class), you can alternatively use composition with the CoroutineTestRule : class MyTest { val rule = CoroutineTestRule () @Test fun someTest () = rule . runBlockingTest { // ... } }","title":"Unit tests with coroutines"},{"location":"reference/","text":"// reactivestate-test reactivestate-test \u00b6 Packages \u00b6 Name com.ensody.reactivestate.test","title":"Index"},{"location":"reference/#reactivestate-test","text":"","title":"reactivestate-test"},{"location":"reference/#packages","text":"Name com.ensody.reactivestate.test","title":"Packages"},{"location":"reference/reactivestate/com.ensody.reactivestate/","text":"// reactivestate / com.ensody.reactivestate Package-level declarations \u00b6 Functions \u00b6 Name Summary get [android] fun < T > Resolver. get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable.","title":"reactivestate"},{"location":"reference/reactivestate/com.ensody.reactivestate/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"reference/reactivestate/com.ensody.reactivestate/#functions","text":"Name Summary get [android] fun < T > Resolver. get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable.","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate/get/","text":"// reactivestate / com.ensody.reactivestate / get get \u00b6 [android]\\ fun < T > Resolver. get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable.","title":"Get"},{"location":"reference/reactivestate/com.ensody.reactivestate/get/#get","text":"[android]\\ fun < T > Resolver. get (data: LiveData < T >): T ? Returns LiveData.getValue and tracks the observable.","title":"get"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/","text":"// reactivestate / com.ensody.reactivestate.android Package-level declarations \u00b6 Types \u00b6 Name Summary BuildOnViewModelContext [android] class BuildOnViewModelContext (val scope: CoroutineScope, val stateFlowStore: StateFlowStore) Build context for buildOnViewModel . LifecycleCoroutineLauncher [android] class LifecycleCoroutineLauncher (val owner: LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state. SavedStateHandleStore [android] class SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . WrapperViewModel [android] class WrapperViewModel (val stateFlowStore: StateFlowStore) : ViewModel The wrapper ViewModel used by buildOnViewModel . Functions \u00b6 Name Summary activityStateFlowViewModel [android] inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity . activityStateViewModel [android] inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle , scoped to the Activity . activityViewModel [android] inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel scoped to the Activity . attachLazyReactiveState [android] fun < E : ErrorEvents> Lazy <ReactiveState< E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner ) autoRun [android] fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). [android] fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. buildOnViewModel [android] inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. [android] inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. [android] fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > Used internally by buildOnViewModel . buildViewModel [android] inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel . coAutoRun [android] fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. [android] fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). derived [android] fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [android] fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. handleEvents [android] fun < T : ErrorEvents> EventNotifier< T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier\u2019s events on the given handler , but only when owner is in >=STARTED state. onCreate [android] fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_CREATE . onCreateOnce [android] fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY . onCreateView [android] fun Fragment . onCreateView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onCreateView (actually onViewStateRestored ). onCreateViewOnce [android] fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored ). onDestroy [android] fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_DESTROY . onDestroyOnce [android] fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY . onDestroyView [android] fun Fragment . onDestroyView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onDestroyView . onDestroyViewOnce [android] fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onDestroyView . onPause [android] fun LifecycleOwner . onPause (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_PAUSE . onPauseOnce [android] fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_PAUSE . onResume [android] fun LifecycleOwner . onResume (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_RESUME . onResumeOnce [android] fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_RESUME . onStart [android] fun LifecycleOwner . onStart (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_START . onStartOnce [android] fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_START . onStop [android] fun LifecycleOwner . onStop (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_STOP . onStopOnce [android] fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_STOP . reactiveState [android] inline fun < E : ErrorEvents, T : ReactiveState< E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents, T : ReactiveState< E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier. savedInstanceState [android] fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> Returns a StateFlowStore where you can put your saved instance state. stateFlowStore [android] fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore stateFlowViewModel [android] inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore . stateViewModel [android] inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle . Properties \u00b6 Name Summary savedInstanceState [android] val Fragment . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state. val ComponentActivity . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#types","text":"Name Summary BuildOnViewModelContext [android] class BuildOnViewModelContext (val scope: CoroutineScope, val stateFlowStore: StateFlowStore) Build context for buildOnViewModel . LifecycleCoroutineLauncher [android] class LifecycleCoroutineLauncher (val owner: LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state. SavedStateHandleStore [android] class SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . WrapperViewModel [android] class WrapperViewModel (val stateFlowStore: StateFlowStore) : ViewModel The wrapper ViewModel used by buildOnViewModel .","title":"Types"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#functions","text":"Name Summary activityStateFlowViewModel [android] inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity . activityStateViewModel [android] inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle , scoped to the Activity . activityViewModel [android] inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel scoped to the Activity . attachLazyReactiveState [android] fun < E : ErrorEvents> Lazy <ReactiveState< E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner ) autoRun [android] fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). [android] fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. buildOnViewModel [android] inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. [android] inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. [android] fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > Used internally by buildOnViewModel . buildViewModel [android] inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel . coAutoRun [android] fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. [android] fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). derived [android] fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [android] fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. handleEvents [android] fun < T : ErrorEvents> EventNotifier< T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier\u2019s events on the given handler , but only when owner is in >=STARTED state. onCreate [android] fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_CREATE . onCreateOnce [android] fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY . onCreateView [android] fun Fragment . onCreateView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onCreateView (actually onViewStateRestored ). onCreateViewOnce [android] fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored ). onDestroy [android] fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_DESTROY . onDestroyOnce [android] fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY . onDestroyView [android] fun Fragment . onDestroyView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onDestroyView . onDestroyViewOnce [android] fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onDestroyView . onPause [android] fun LifecycleOwner . onPause (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_PAUSE . onPauseOnce [android] fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_PAUSE . onResume [android] fun LifecycleOwner . onResume (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_RESUME . onResumeOnce [android] fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_RESUME . onStart [android] fun LifecycleOwner . onStart (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_START . onStartOnce [android] fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_START . onStop [android] fun LifecycleOwner . onStop (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_STOP . onStopOnce [android] fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_STOP . reactiveState [android] inline fun < E : ErrorEvents, T : ReactiveState< E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents, T : ReactiveState< E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier. savedInstanceState [android] fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> Returns a StateFlowStore where you can put your saved instance state. stateFlowStore [android] fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore stateFlowViewModel [android] inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore . stateViewModel [android] inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle .","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/#properties","text":"Name Summary savedInstanceState [android] val Fragment . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state. val ComponentActivity . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state.","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-flow-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / activityStateFlowViewModel activityStateFlowViewModel \u00b6 [android]\\ inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Activity state flow view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-flow-view-model/#activitystateflowviewmodel","text":"[android]\\ inline fun < T : ViewModel > Fragment . activityStateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore , scoped to the Activity . The provider should instantiate the ViewModel directly.","title":"activityStateFlowViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-flow-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / activityStateViewModel activityStateViewModel \u00b6 [android]\\ inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle , scoped to the Activity . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Activity state view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-view-model/#activitystateviewmodel","text":"[android]\\ inline fun < T : ViewModel > Fragment . activityStateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle , scoped to the Activity . The provider should instantiate the ViewModel directly.","title":"activityStateViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-state-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / activityViewModel activityViewModel \u00b6 [android]\\ inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel scoped to the Activity . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Activity view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-view-model/#activityviewmodel","text":"[android]\\ inline fun < T : ViewModel > Fragment . activityViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel scoped to the Activity . The provider should instantiate the ViewModel directly.","title":"activityViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/activity-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/attach-lazy-reactive-state/","text":"// reactivestate / com.ensody.reactivestate.android / attachLazyReactiveState attachLazyReactiveState \u00b6 [android]\\ fun < E : ErrorEvents> Lazy <ReactiveState< E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner )","title":"Attach lazy reactive state"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/attach-lazy-reactive-state/#attachlazyreactivestate","text":"[android]\\ fun < E : ErrorEvents> Lazy <ReactiveState< E >>. attachLazyReactiveState (handler: E ?, owner: LifecycleOwner )","title":"attachLazyReactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/","text":"// reactivestate / com.ensody.reactivestate.android / autoRun autoRun \u00b6 [android]\\ fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android]\\ fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart / onStop . Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy / Fragment.onDestroyView . See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Auto run"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/#autorun","text":"[android]\\ fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details.","title":"autoRun"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/#parameters","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android]\\ fun LifecycleOwner . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart / onStop . Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy / Fragment.onDestroyView . See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/auto-run/#parameters_1","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / buildOnViewModel buildOnViewModel \u00b6 [android]\\ inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. The provider should instantiate the object directly. See also \u00b6 android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android]\\ inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. The provider should instantiate the object directly. See also \u00b6 android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android]\\ fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > Used internally by buildOnViewModel .","title":"Build on view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/#buildonviewmodel","text":"[android]\\ inline fun < T : Any > Fragment . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. The provider should instantiate the object directly.","title":"buildOnViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/#see-also","text":"android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android]\\ inline fun < T : Any > ComponentActivity . buildOnViewModel (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates an object living on a wrapper ViewModel . This allows for building multiplatform ViewModels. The provider should instantiate the object directly.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-on-view-model/#see-also_1","text":"android reactiveState if you want to instantiate a multiplatform ReactiveState ViewModel directly. [android]\\ fun < T : Any > Lazy < WrapperViewModel >. buildOnViewModel (klass: KClass < T >, caster: ( Any ?) -> T ?, provider: BuildOnViewModelContext .() -> T ): Lazy < T > Used internally by buildOnViewModel .","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / buildViewModel buildViewModel \u00b6 [android]\\ inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"Build view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-view-model/#buildviewmodel","text":"[android]\\ inline fun < T : ViewModel > Fragment . buildViewModel (crossinline provider: () -> T ): Lazy < T > inline fun < T : ViewModel > ComponentActivity . buildViewModel (crossinline provider: () -> T ): Lazy < T > Creates a ViewModel . The provider should instantiate the ViewModel directly.","title":"buildViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/build-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/","text":"// reactivestate / com.ensody.reactivestate.android / coAutoRun coAutoRun \u00b6 [android]\\ fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android]\\ fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart / onStop . Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy / Fragment.onDestroyView . See AutoRunner for more details. Parameters \u00b6 android onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to conflatedWorker. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Co auto run"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/#coautorun","text":"[android]\\ fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the viewModelScope completes. See AutoRunner for more details.","title":"coAutoRun"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/#parameters","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [android]\\ fun LifecycleOwner . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback< Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: AutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This only executes the observer between onStart / onStop . Returns the underlying AutoRunner. To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed on Activity.onDestroy / Fragment.onDestroyView . See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/co-auto-run/#parameters_1","text":"android onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to conflatedWorker. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/derived/","text":"// reactivestate / com.ensody.reactivestate.android / derived derived \u00b6 [android]\\ fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [android]\\ fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed. Parameters \u00b6 android initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Derived"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/derived/#derived","text":"[android]\\ fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > fun < T > LifecycleOwner . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [android]\\ fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > fun < T > LifecycleOwner . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else LifecycleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed.","title":"derived"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/derived/#parameters","text":"android initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker. dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading if this is a CoroutineLauncher or null otherwise. observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/handle-events/","text":"// reactivestate / com.ensody.reactivestate.android / handleEvents handleEvents \u00b6 [android]\\ fun < T : ErrorEvents> EventNotifier< T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier\u2019s events on the given handler , but only when owner is in >=STARTED state. IMPORTANT: You have to call this function exactly once for the whole lifecycle of owner . Usually that means Activity.onCreate / Fragment.onViewCreated . Any errors during event handling will trigger ErrorEvents.onError on the handler . WARNING: Try to avoid switching threads within your handler \u2018s methods! Otherwise your operation can get canceled and lost when rotating or locking the screen. Always stay on the main thread.","title":"Handle events"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/handle-events/#handleevents","text":"[android]\\ fun < T : ErrorEvents> EventNotifier< T >. handleEvents (handler: T , owner: LifecycleOwner ) Consumes and handles EventNotifier\u2019s events on the given handler , but only when owner is in >=STARTED state. IMPORTANT: You have to call this function exactly once for the whole lifecycle of owner . Usually that means Activity.onCreate / Fragment.onViewCreated . Any errors during event handling will trigger ErrorEvents.onError on the handler . WARNING: Try to avoid switching threads within your handler \u2018s methods! Otherwise your operation can get canceled and lost when rotating or locking the screen. Always stay on the main thread.","title":"handleEvents"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-once/","text":"// reactivestate / com.ensody.reactivestate.android / onCreateOnce onCreateOnce \u00b6 [android]\\ fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY . Return \u00b6 Disposable that allows removing the observer.","title":"On create once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-once/#oncreateonce","text":"[android]\\ fun LifecycleOwner . onCreateOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY .","title":"onCreateOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view-once/","text":"// reactivestate / com.ensody.reactivestate.android / onCreateViewOnce onCreateViewOnce \u00b6 [android]\\ fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored ). Return \u00b6 Disposable that allows removing the observer.","title":"On create view once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view-once/#oncreateviewonce","text":"[android]\\ fun Fragment . onCreateViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onCreateView (actually onViewStateRestored ).","title":"onCreateViewOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view/","text":"// reactivestate / com.ensody.reactivestate.android / onCreateView onCreateView \u00b6 [android]\\ fun Fragment . onCreateView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onCreateView (actually onViewStateRestored ). Return \u00b6 Disposable that allows removing the observer.","title":"On create view"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view/#oncreateview","text":"[android]\\ fun Fragment . onCreateView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onCreateView (actually onViewStateRestored ).","title":"onCreateView"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create-view/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create/","text":"// reactivestate / com.ensody.reactivestate.android / onCreate onCreate \u00b6 [android]\\ fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_CREATE . Return \u00b6 Disposable that allows removing the observer.","title":"On create"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create/#oncreate","text":"[android]\\ fun LifecycleOwner . onCreate (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_CREATE .","title":"onCreate"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-create/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-once/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroyOnce onDestroyOnce \u00b6 [android]\\ fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY . Return \u00b6 Disposable that allows removing the observer.","title":"On destroy once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-once/#ondestroyonce","text":"[android]\\ fun LifecycleOwner . onDestroyOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_DESTROY .","title":"onDestroyOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view-once/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroyViewOnce onDestroyViewOnce \u00b6 [android]\\ fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onDestroyView . Return \u00b6 Disposable that allows removing the observer.","title":"On destroy view once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view-once/#ondestroyviewonce","text":"[android]\\ fun Fragment . onDestroyViewOnce (block: () -> Unit ): Disposable Runs the given block once on the next Fragment.onDestroyView .","title":"onDestroyViewOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroyView onDestroyView \u00b6 [android]\\ fun Fragment . onDestroyView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onDestroyView . Return \u00b6 Disposable that allows removing the observer.","title":"On destroy view"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view/#ondestroyview","text":"[android]\\ fun Fragment . onDestroyView (block: () -> Unit ): Disposable Runs the given block on every Fragment.onDestroyView .","title":"onDestroyView"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy-view/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy/","text":"// reactivestate / com.ensody.reactivestate.android / onDestroy onDestroy \u00b6 [android]\\ fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_DESTROY . Return \u00b6 Disposable that allows removing the observer.","title":"On destroy"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy/#ondestroy","text":"[android]\\ fun LifecycleOwner . onDestroy (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_DESTROY .","title":"onDestroy"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-destroy/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause-once/","text":"// reactivestate / com.ensody.reactivestate.android / onPauseOnce onPauseOnce \u00b6 [android]\\ fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_PAUSE . Return \u00b6 Disposable that allows removing the observer.","title":"On pause once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause-once/#onpauseonce","text":"[android]\\ fun LifecycleOwner . onPauseOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_PAUSE .","title":"onPauseOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause/","text":"// reactivestate / com.ensody.reactivestate.android / onPause onPause \u00b6 [android]\\ fun LifecycleOwner . onPause (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_PAUSE . Return \u00b6 Disposable that allows removing the observer.","title":"On pause"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause/#onpause","text":"[android]\\ fun LifecycleOwner . onPause (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_PAUSE .","title":"onPause"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-pause/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume-once/","text":"// reactivestate / com.ensody.reactivestate.android / onResumeOnce onResumeOnce \u00b6 [android]\\ fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_RESUME . Return \u00b6 Disposable that allows removing the observer.","title":"On resume once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume-once/#onresumeonce","text":"[android]\\ fun LifecycleOwner . onResumeOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_RESUME .","title":"onResumeOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume/","text":"// reactivestate / com.ensody.reactivestate.android / onResume onResume \u00b6 [android]\\ fun LifecycleOwner . onResume (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_RESUME . Return \u00b6 Disposable that allows removing the observer.","title":"On resume"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume/#onresume","text":"[android]\\ fun LifecycleOwner . onResume (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_RESUME .","title":"onResume"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-resume/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start-once/","text":"// reactivestate / com.ensody.reactivestate.android / onStartOnce onStartOnce \u00b6 [android]\\ fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_START . Return \u00b6 Disposable that allows removing the observer.","title":"On start once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start-once/#onstartonce","text":"[android]\\ fun LifecycleOwner . onStartOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_START .","title":"onStartOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start/","text":"// reactivestate / com.ensody.reactivestate.android / onStart onStart \u00b6 [android]\\ fun LifecycleOwner . onStart (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_START . Return \u00b6 Disposable that allows removing the observer.","title":"On start"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start/#onstart","text":"[android]\\ fun LifecycleOwner . onStart (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_START .","title":"onStart"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-start/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop-once/","text":"// reactivestate / com.ensody.reactivestate.android / onStopOnce onStopOnce \u00b6 [android]\\ fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_STOP . Return \u00b6 Disposable that allows removing the observer.","title":"On stop once"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop-once/#onstoponce","text":"[android]\\ fun LifecycleOwner . onStopOnce (block: () -> Unit ): Disposable Runs the given block once on the next Lifecycle.Event.ON_STOP .","title":"onStopOnce"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop-once/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop/","text":"// reactivestate / com.ensody.reactivestate.android / onStop onStop \u00b6 [android]\\ fun LifecycleOwner . onStop (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_STOP . Return \u00b6 Disposable that allows removing the observer.","title":"On stop"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop/#onstop","text":"[android]\\ fun LifecycleOwner . onStop (block: () -> Unit ): Disposable Runs the given block on every Lifecycle.Event.ON_STOP .","title":"onStop"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/on-stop/#return","text":"Disposable that allows removing the observer.","title":"Return"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/reactive-state/","text":"// reactivestate / com.ensody.reactivestate.android / reactiveState reactiveState \u00b6 [android]\\ inline fun < E : ErrorEvents, T : ReactiveState< E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents, T : ReactiveState< E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier. The provider should instantiate the object directly.","title":"Reactive state"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/reactive-state/#reactivestate","text":"[android]\\ inline fun < E : ErrorEvents, T : ReactiveState< E >> Fragment . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > inline fun < E : ErrorEvents, T : ReactiveState< E >> ComponentActivity . reactiveState (crossinline provider: BuildOnViewModelContext .() -> T ): Lazy < T > Creates a multiplatform ReactiveState ViewModel and observes its ReactiveState.eventNotifier. The provider should instantiate the object directly.","title":"reactiveState"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/saved-instance-state/","text":"// reactivestate / com.ensody.reactivestate.android / savedInstanceState savedInstanceState \u00b6 [android]\\ fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> val Fragment . savedInstanceState : StateFlowStore val ComponentActivity . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state.","title":"Saved instance state"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/saved-instance-state/#savedinstancestate","text":"[android]\\ fun < T > Fragment . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> fun < T > ComponentActivity . savedInstanceState (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow< T >> val Fragment . savedInstanceState : StateFlowStore val ComponentActivity . savedInstanceState : StateFlowStore Returns a StateFlowStore where you can put your saved instance state.","title":"savedInstanceState"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-store/","text":"// reactivestate / com.ensody.reactivestate.android / stateFlowStore stateFlowStore \u00b6 [android]\\ fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore","title":"State flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-store/#stateflowstore","text":"[android]\\ fun SavedStateHandle . stateFlowStore (scope: CoroutineScope): SavedStateHandleStore","title":"stateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / stateFlowViewModel stateFlowViewModel \u00b6 [android]\\ inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"State flow view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-view-model/#stateflowviewmodel","text":"[android]\\ inline fun < T : ViewModel > ComponentActivity . stateFlowViewModel (crossinline provider: (handle: SavedStateHandleStore ) -> T ): Lazy < T > inline fun < T : ViewModel > Fragment . stateFlowViewModel (crossinline provider: (store: SavedStateHandleStore ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandleStore . The provider should instantiate the ViewModel directly.","title":"stateFlowViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-flow-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / stateViewModel stateViewModel \u00b6 [android]\\ inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle . The provider should instantiate the ViewModel directly. See also \u00b6 android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"State view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-view-model/#stateviewmodel","text":"[android]\\ inline fun < T : ViewModel > Fragment . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > inline fun < T : ViewModel > ComponentActivity . stateViewModel (crossinline provider: (handle: SavedStateHandle ) -> T ): Lazy < T > Creates a ViewModel with a SavedStateHandle . The provider should instantiate the ViewModel directly.","title":"stateViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/state-view-model/#see-also","text":"android reactiveState if you want to create multiplatform ReactiveState ViewModels.","title":"See also"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext BuildOnViewModelContext \u00b6 [android]\\ class BuildOnViewModelContext (val scope: CoroutineScope, val stateFlowStore: StateFlowStore) Build context for buildOnViewModel . Constructors \u00b6 BuildOnViewModelContext [android] fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore) Properties \u00b6 Name Summary scope [android] val scope : CoroutineScope The viewModelScope . stateFlowStore [android] val stateFlowStore : StateFlowStore A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/#buildonviewmodelcontext","text":"[android]\\ class BuildOnViewModelContext (val scope: CoroutineScope, val stateFlowStore: StateFlowStore) Build context for buildOnViewModel .","title":"BuildOnViewModelContext"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/#constructors","text":"BuildOnViewModelContext [android] fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore)","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/#properties","text":"Name Summary scope [android] val scope : CoroutineScope The viewModelScope . stateFlowStore [android] val stateFlowStore : StateFlowStore A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/-build-on-view-model-context/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext / BuildOnViewModelContext BuildOnViewModelContext \u00b6 [android]\\ fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore)","title":" build on view model context"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/-build-on-view-model-context/#buildonviewmodelcontext","text":"[android]\\ fun BuildOnViewModelContext (scope: CoroutineScope, stateFlowStore: StateFlowStore)","title":"BuildOnViewModelContext"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/scope/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext / scope scope \u00b6 [android]\\ val scope : CoroutineScope The viewModelScope .","title":"Scope"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/scope/#scope","text":"[android]\\ val scope : CoroutineScope The viewModelScope .","title":"scope"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/state-flow-store/","text":"// reactivestate / com.ensody.reactivestate.android / BuildOnViewModelContext / stateFlowStore stateFlowStore \u00b6 [android]\\ val stateFlowStore : StateFlowStore A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"State flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-build-on-view-model-context/state-flow-store/#stateflowstore","text":"[android]\\ val stateFlowStore : StateFlowStore A StateFlowStore where you can store/load the saved instance state (similar to a SavedStateHandle ).","title":"stateFlowStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher LifecycleCoroutineLauncher \u00b6 [android]\\ class LifecycleCoroutineLauncher (val owner: LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state. Constructors \u00b6 LifecycleCoroutineLauncher [android] fun LifecycleCoroutineLauncher (owner: LifecycleOwner ) Functions \u00b6 Name Summary launch [android] open fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow< Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job onError [android] open override fun onError (error: Throwable ) rawLaunch [android] open override fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job track [android] open suspend fun track (withLoading: MutableValueFlow< Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend () -> Unit ) Properties \u00b6 Name Summary launcherScope [android] override val launcherScope : CoroutineScope loading [android] override val loading : MutableValueFlow< Int > owner [android] val owner : LifecycleOwner","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#lifecyclecoroutinelauncher","text":"[android]\\ class LifecycleCoroutineLauncher (val owner: LifecycleOwner ) : SimpleCoroutineLauncher A SimpleCoroutineLauncher that launches coroutines in the STARTED state.","title":"LifecycleCoroutineLauncher"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#constructors","text":"LifecycleCoroutineLauncher [android] fun LifecycleCoroutineLauncher (owner: LifecycleOwner )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#functions","text":"Name Summary launch [android] open fun launch (context: CoroutineContext , start: CoroutineStart, withLoading: MutableValueFlow< Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend CoroutineScope.() -> Unit ): Job onError [android] open override fun onError (error: Throwable ) rawLaunch [android] open override fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job track [android] open suspend fun track (withLoading: MutableValueFlow< Int >?, onError: suspend ( Throwable ) -> Unit ?, block: suspend () -> Unit )","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/#properties","text":"Name Summary launcherScope [android] override val launcherScope : CoroutineScope loading [android] override val loading : MutableValueFlow< Int > owner [android] val owner : LifecycleOwner","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/-lifecycle-coroutine-launcher/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher / LifecycleCoroutineLauncher LifecycleCoroutineLauncher \u00b6 [android]\\ fun LifecycleCoroutineLauncher (owner: LifecycleOwner )","title":" lifecycle coroutine launcher"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/-lifecycle-coroutine-launcher/#lifecyclecoroutinelauncher","text":"[android]\\ fun LifecycleCoroutineLauncher (owner: LifecycleOwner )","title":"LifecycleCoroutineLauncher"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/on-error/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher / onError onError \u00b6 [android]\\ open override fun onError (error: Throwable )","title":"On error"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/on-error/#onerror","text":"[android]\\ open override fun onError (error: Throwable )","title":"onError"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/owner/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher / owner owner \u00b6 [android]\\ val owner : LifecycleOwner","title":"Owner"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/owner/#owner","text":"[android]\\ val owner : LifecycleOwner","title":"owner"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/raw-launch/","text":"// reactivestate / com.ensody.reactivestate.android / LifecycleCoroutineLauncher / rawLaunch rawLaunch \u00b6 [android]\\ open override fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job","title":"Raw launch"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-lifecycle-coroutine-launcher/raw-launch/#rawlaunch","text":"[android]\\ open override fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job","title":"rawLaunch"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore SavedStateHandleStore \u00b6 [android]\\ class SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . This can synchronize either two-way (MutableValueFlow<-> LiveData ) if scope is not null one-way (MutableValueFlow -> LiveData ) if scope is null Depending on whether you already have a scope Constructors \u00b6 SavedStateHandleStore [android] fun SavedStateHandleStore (savedStateHandle: SavedStateHandle ) Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData . SavedStateHandleStore [android] fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle ) Functions \u00b6 Name Summary contains [android] open operator override fun contains (key: String ): Boolean getData [android] open override fun < T > getData (key: String , default: T ): MutableValueFlow< T >","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/#savedstatehandlestore","text":"[android]\\ class SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle ) : StateFlowStore A StateFlowStore that wraps a SavedStateHandle . This can synchronize either two-way (MutableValueFlow<-> LiveData ) if scope is not null one-way (MutableValueFlow -> LiveData ) if scope is null Depending on whether you already have a scope","title":"SavedStateHandleStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/#constructors","text":"SavedStateHandleStore [android] fun SavedStateHandleStore (savedStateHandle: SavedStateHandle ) Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData . SavedStateHandleStore [android] fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle )","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/#functions","text":"Name Summary contains [android] open operator override fun contains (key: String ): Boolean getData [android] open override fun < T > getData (key: String , default: T ): MutableValueFlow< T >","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/-saved-state-handle-store/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore / SavedStateHandleStore SavedStateHandleStore \u00b6 [android]\\ fun SavedStateHandleStore (savedStateHandle: SavedStateHandle ) Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData . [android]\\ fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle )","title":" saved state handle store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/-saved-state-handle-store/#savedstatehandlestore","text":"[android]\\ fun SavedStateHandleStore (savedStateHandle: SavedStateHandle ) Wraps the given SavedStateHandle and synchronizes one-way from MutableValueFlow to LiveData . [android]\\ fun SavedStateHandleStore (scope: CoroutineScope?, savedStateHandle: SavedStateHandle )","title":"SavedStateHandleStore"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/contains/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore / contains contains \u00b6 [android]\\ open operator override fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/contains/#contains","text":"[android]\\ open operator override fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/get-data/","text":"// reactivestate / com.ensody.reactivestate.android / SavedStateHandleStore / getData getData \u00b6 [android]\\ open override fun < T > getData (key: String , default: T ): MutableValueFlow< T >","title":"Get data"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-saved-state-handle-store/get-data/#getdata","text":"[android]\\ open override fun < T > getData (key: String , default: T ): MutableValueFlow< T >","title":"getData"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel WrapperViewModel \u00b6 [android]\\ class WrapperViewModel (val stateFlowStore: StateFlowStore) : ViewModel The wrapper ViewModel used by buildOnViewModel . Constructors \u00b6 WrapperViewModel [android] fun WrapperViewModel (stateFlowStore: StateFlowStore) Functions \u00b6 Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable ) Properties \u00b6 Name Summary registry [android] val registry : MutableMap < KClass <*>, Any > stateFlowStore [android] val stateFlowStore : StateFlowStore Extensions \u00b6 Name Summary autoRun [android] fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. coAutoRun [android] fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. derived [android] fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [android] fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block.","title":"Index"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#wrapperviewmodel","text":"[android]\\ class WrapperViewModel (val stateFlowStore: StateFlowStore) : ViewModel The wrapper ViewModel used by buildOnViewModel .","title":"WrapperViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#constructors","text":"WrapperViewModel [android] fun WrapperViewModel (stateFlowStore: StateFlowStore)","title":"Constructors"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#functions","text":"Name Summary addCloseable [android] open fun addCloseable (@ NonNull p0: Closeable )","title":"Functions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#properties","text":"Name Summary registry [android] val registry : MutableMap < KClass <*>, Any > stateFlowStore [android] val stateFlowStore : StateFlowStore","title":"Properties"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/#extensions","text":"Name Summary autoRun [android] fun ViewModel . autoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: AutoRunOnChangeCallback< Unit >? = null, observer: AutoRunCallback< Unit >): AutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. coAutoRun [android] fun ViewModel . coAutoRun (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), onChange: CoAutoRunOnChangeCallback< Unit >? = null, observer: CoAutoRunCallback< Unit >): CoAutoRunner< Unit > Watches observables for changes. Often useful to keep things in sync. derived [android] fun < T > ViewModel . derived (launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), observer: AutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [android] fun < T > ViewModel . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = if (this is CoroutineLauncher) this else SimpleCoroutineLauncher(viewModelScope), flowTransformer: DerivedFlowTransformer< T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow< Int >? = if (this is CoroutineLauncher) launcher.loading else null, observer: CoAutoRunCallback< T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block.","title":"Extensions"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/-wrapper-view-model/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel / WrapperViewModel WrapperViewModel \u00b6 [android]\\ fun WrapperViewModel (stateFlowStore: StateFlowStore)","title":" wrapper view model"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/-wrapper-view-model/#wrapperviewmodel","text":"[android]\\ fun WrapperViewModel (stateFlowStore: StateFlowStore)","title":"WrapperViewModel"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/registry/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel / registry registry \u00b6 [android]\\ val registry : MutableMap < KClass <*>, Any >","title":"Registry"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/registry/#registry","text":"[android]\\ val registry : MutableMap < KClass <*>, Any >","title":"registry"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/state-flow-store/","text":"// reactivestate / com.ensody.reactivestate.android / WrapperViewModel / stateFlowStore stateFlowStore \u00b6 [android]\\ val stateFlowStore : StateFlowStore","title":"State flow store"},{"location":"reference/reactivestate/com.ensody.reactivestate.android/-wrapper-view-model/state-flow-store/#stateflowstore","text":"[android]\\ val stateFlowStore : StateFlowStore","title":"stateFlowStore"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/","text":"// reactivestate-core / com.ensody.reactivestate Package-level declarations \u00b6 Types \u00b6 Name Summary ApplyFlowTransform [common] typealias ApplyFlowTransform < T , R > = Flow< T >.( FlowTransform < T , R >) -> Flow< R > A function applying a Flow.transform and possibly additional Flow configurations. AttachedDisposables [common] interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposable s attached to it, so they are automatically disposed together with this object. AutoRunCallback [common] typealias AutoRunCallback < T > = Resolver .() -> T Observer callback used by autoRun and AutoRunner . AutoRunFlowTransformer [common] typealias AutoRunFlowTransformer = DerivedFlowTransformer < Unit > Collector of the change events used by coAutoRun and CoAutoRunner . AutoRunner [common] class AutoRunner < T >(val launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the synchronous version. See CoAutoRunner for the suspension function based version. AutoRunnerObservable [common] interface AutoRunnerObservable < T > Base interface for observing a hard-coded AutoRunner instance. AutoRunOnChangeCallback [common] typealias AutoRunOnChangeCallback < T > = ( AutoRunner < T >) -> Unit onChange callback used by autoRun and AutoRunner . BaseAutoRunner [common] abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . No generic types. BaseReactiveState [common] open class BaseReactiveState < E : ErrorEvents >(scope: CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. BaseSuspendMutableValueFlow [common] @ ExperimentalReactiveStateApi abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value. CoAutoRunCallback [common] typealias CoAutoRunCallback < T > = suspend Resolver .() -> T Observer callback used by suspendable coAutoRun and CoAutoRunner . CoAutoRunner [common] class CoAutoRunner < T >(val launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the suspension function based version. See AutoRunner for the synchronous version. CoAutoRunOnChangeCallback [common] typealias CoAutoRunOnChangeCallback < T > = suspend ( CoAutoRunner < T >) -> Unit onChange callback used by suspendable coAutoRun and CoAutoRunner . CoroutineDispatcherConfig [common] interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers. CoroutineLauncher [common] interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. DefaultCoroutineDispatcherConfig [common] object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers. DependencyAccessor [common] @ Target (allowedTargets = [ AnnotationTarget.PROPERTY ]) annotation class DependencyAccessor Marks dependency injection system accessors, so direct access must be explicitly opted in. DerivedFlowTransformer [common] typealias DerivedFlowTransformer < T > = ApplyFlowTransform < Unit , T > Collector of the change events used by derived . Disposable [common] typealias Disposable = DisposableHandle An object that can be disposed/deactivated/canceled by calling dispose() . This is an alias for DisposableHandle. DisposableGroup [common] interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. DisposableValue [common] class DisposableValue < T >(val value: T , disposer: () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore. ErrorEvents [common] interface ErrorEvents Events interface with a simple onError event (e.g. for use with EventNotifier ). EventNotifier [common] interface EventNotifier < T > : MutableFlow < T .() -> Unit > This is used to send events to an observer. All events are queued for later processing. ExperimentalReactiveStateApi [common] annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases. FlowTransform [common] typealias FlowTransform < T , R > = suspend FlowCollector< R >.( T ) -> Unit A function which can be passed to Flow.transform. InMemoryStateFlowStore [common] class InMemoryStateFlowStore (val underlyingData: MutableMap < String , Any ?> = mutableMapOf()) : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects. InternalBaseAutoRunner [common] abstract class InternalBaseAutoRunner (val launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer ) : BaseAutoRunner JobDisposable [common] class JobDisposable (job: Job) : DisposableHandle A Disposable wrapping a Job. MutableFlow [common] interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel). MutableValueFlow [common] interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. Assigning to .value still has distinctUntilChanged behavior, but emit / tryEmit and update always trigger a change event. NamespacedStateFlowStore [common] class NamespacedStateFlowStore (store: StateFlowStore , namespace: String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. OnDispose [common] class OnDispose (function: () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose() . OnReactiveStateAttached [common] interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. ReactiveState [common] interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Resolver [common] class Resolver (val autoRunner: BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner . Serializable [common] expect interface Serializable Maps to java.io.Serializable on JVM. [nonJvm, jvmCommon] [nonJvm] actual interface Serializable [jvmCommon] actual typealias Serializable = <Error class: unknown class> SimpleCoroutineLauncher [common] open class SimpleCoroutineLauncher (val launcherScope: CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. StateFlowStore [common] interface StateFlowStore Base interface for a temporary observable key-value store. StateFlowStoreFactory [common] typealias StateFlowStoreFactory = (CoroutineScope) -> StateFlowStore A factory function creating a StateFlowStore. SuspendMutableValueFlow [common] @ ExperimentalReactiveStateApi interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value. ValueFlow [common] interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks. WhileUsed [common] class WhileUsed < T >(retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsedReferenceToken [common] class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function. Wrapped [common] class Wrapped < T >(val value: T ) : Serializable , ReadOnlyProperty < Any ?, T > Wraps a value. Together with nullability can model an Option / Maybe . Functions \u00b6 Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. afterUpdate [common] fun < T > MutableStateFlow< T >. afterUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter after doing the actual value update. attachTo [common] fun ReactiveState <out ErrorEvents >. attachTo (owner: Any ) autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). [common] fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). beforeUpdate [common] fun < T > MutableStateFlow< T >. beforeUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter before doing the actual value update. childReactiveState [common] fun < E : ErrorEvents , P : ReactiveState <out E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > Creates and attaches a child ReactiveState . coAutoRun [common] fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. decrement [common] fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . derived [common] fun < T > derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. derivedWhileSubscribed [common] fun < T > derivedWhileSubscribed (initial: T , flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. DisposableGroup [common] fun DisposableGroup (): DisposableGroup Constructs a DisposableGroup . disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). EventNotifier [common] fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > Creates an EventNotifier . get [common] fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used. [common] fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope ). getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name. handleEvents [common] suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . increment [common] fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom [common] suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher . [common] fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineContext . [common] fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineScope. isFatal [common, jvmCommon, nonJvm] [common] expect fun Throwable . isFatal (): Boolean [jvmCommon, nonJvm] actual fun Throwable . isFatal (): Boolean latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest. lazyProperty [common] fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > A helper for creating a lazily computed ReadOnlyProperty based on a KProperty . MutableFlow [common] fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > Creates a MutableFlow . MutableValueFlow [common] fun < T > MutableValueFlow (value: T , setter: (value: T ) -> Unit ? = null): MutableValueFlow < T > Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations. propertyName [common] inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > A lazyProperty that only receives the KProperty.name as its argument. replace [common] fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. runCatchingNonFatal [common] inline fun < T > runCatchingNonFatal (block: () -> T ): Result < T > Similar to the stdlib runCatching , but uses throwIfFatal to re-throw fatal exceptions immediately. SuspendMutableValueFlow [common] @ ExperimentalReactiveStateApi fun < T > SuspendMutableValueFlow (value: T , setter: suspend (value: T ) -> Unit ): SuspendMutableValueFlow < T > throwIfFatal [common] inline fun < T : Throwable > T . throwIfFatal (): T Throws this exception if it\u2019s fatal. Otherwise returns it. validUntil [common] fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > Creates an automatically invalidated property. withErrorReporting [common] inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) Executes the given block , catching any errors and reporting them to the given eventNotifier . [common] inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) Executes the given block , catching any errors and calling onError , but handling CancellationException. withSetter [common] fun < T > MutableStateFlow< T >. withSetter (setter: MutableStateFlow< T >.( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter instead of doing the actual value update. Properties \u00b6 Name Summary dispatchers [common] var dispatchers : CoroutineDispatcherConfig The currently active CoroutineDispatcherConfig .","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/#types","text":"Name Summary ApplyFlowTransform [common] typealias ApplyFlowTransform < T , R > = Flow< T >.( FlowTransform < T , R >) -> Flow< R > A function applying a Flow.transform and possibly additional Flow configurations. AttachedDisposables [common] interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposable s attached to it, so they are automatically disposed together with this object. AutoRunCallback [common] typealias AutoRunCallback < T > = Resolver .() -> T Observer callback used by autoRun and AutoRunner . AutoRunFlowTransformer [common] typealias AutoRunFlowTransformer = DerivedFlowTransformer < Unit > Collector of the change events used by coAutoRun and CoAutoRunner . AutoRunner [common] class AutoRunner < T >(val launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the synchronous version. See CoAutoRunner for the suspension function based version. AutoRunnerObservable [common] interface AutoRunnerObservable < T > Base interface for observing a hard-coded AutoRunner instance. AutoRunOnChangeCallback [common] typealias AutoRunOnChangeCallback < T > = ( AutoRunner < T >) -> Unit onChange callback used by autoRun and AutoRunner . BaseAutoRunner [common] abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . No generic types. BaseReactiveState [common] open class BaseReactiveState < E : ErrorEvents >(scope: CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. BaseSuspendMutableValueFlow [common] @ ExperimentalReactiveStateApi abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value. CoAutoRunCallback [common] typealias CoAutoRunCallback < T > = suspend Resolver .() -> T Observer callback used by suspendable coAutoRun and CoAutoRunner . CoAutoRunner [common] class CoAutoRunner < T >(val launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the suspension function based version. See AutoRunner for the synchronous version. CoAutoRunOnChangeCallback [common] typealias CoAutoRunOnChangeCallback < T > = suspend ( CoAutoRunner < T >) -> Unit onChange callback used by suspendable coAutoRun and CoAutoRunner . CoroutineDispatcherConfig [common] interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers. CoroutineLauncher [common] interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. DefaultCoroutineDispatcherConfig [common] object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers. DependencyAccessor [common] @ Target (allowedTargets = [ AnnotationTarget.PROPERTY ]) annotation class DependencyAccessor Marks dependency injection system accessors, so direct access must be explicitly opted in. DerivedFlowTransformer [common] typealias DerivedFlowTransformer < T > = ApplyFlowTransform < Unit , T > Collector of the change events used by derived . Disposable [common] typealias Disposable = DisposableHandle An object that can be disposed/deactivated/canceled by calling dispose() . This is an alias for DisposableHandle. DisposableGroup [common] interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. DisposableValue [common] class DisposableValue < T >(val value: T , disposer: () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore. ErrorEvents [common] interface ErrorEvents Events interface with a simple onError event (e.g. for use with EventNotifier ). EventNotifier [common] interface EventNotifier < T > : MutableFlow < T .() -> Unit > This is used to send events to an observer. All events are queued for later processing. ExperimentalReactiveStateApi [common] annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases. FlowTransform [common] typealias FlowTransform < T , R > = suspend FlowCollector< R >.( T ) -> Unit A function which can be passed to Flow.transform. InMemoryStateFlowStore [common] class InMemoryStateFlowStore (val underlyingData: MutableMap < String , Any ?> = mutableMapOf()) : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects. InternalBaseAutoRunner [common] abstract class InternalBaseAutoRunner (val launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer ) : BaseAutoRunner JobDisposable [common] class JobDisposable (job: Job) : DisposableHandle A Disposable wrapping a Job. MutableFlow [common] interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel). MutableValueFlow [common] interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. Assigning to .value still has distinctUntilChanged behavior, but emit / tryEmit and update always trigger a change event. NamespacedStateFlowStore [common] class NamespacedStateFlowStore (store: StateFlowStore , namespace: String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. OnDispose [common] class OnDispose (function: () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose() . OnReactiveStateAttached [common] interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. ReactiveState [common] interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Resolver [common] class Resolver (val autoRunner: BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner . Serializable [common] expect interface Serializable Maps to java.io.Serializable on JVM. [nonJvm, jvmCommon] [nonJvm] actual interface Serializable [jvmCommon] actual typealias Serializable = <Error class: unknown class> SimpleCoroutineLauncher [common] open class SimpleCoroutineLauncher (val launcherScope: CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. StateFlowStore [common] interface StateFlowStore Base interface for a temporary observable key-value store. StateFlowStoreFactory [common] typealias StateFlowStoreFactory = (CoroutineScope) -> StateFlowStore A factory function creating a StateFlowStore. SuspendMutableValueFlow [common] @ ExperimentalReactiveStateApi interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value. ValueFlow [common] interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks. WhileUsed [common] class WhileUsed < T >(retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsedReferenceToken [common] class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function. Wrapped [common] class Wrapped < T >(val value: T ) : Serializable , ReadOnlyProperty < Any ?, T > Wraps a value. Together with nullability can model an Option / Maybe .","title":"Types"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/#functions","text":"Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. afterUpdate [common] fun < T > MutableStateFlow< T >. afterUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter after doing the actual value update. attachTo [common] fun ReactiveState <out ErrorEvents >. attachTo (owner: Any ) autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). [common] fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). beforeUpdate [common] fun < T > MutableStateFlow< T >. beforeUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter before doing the actual value update. childReactiveState [common] fun < E : ErrorEvents , P : ReactiveState <out E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > Creates and attaches a child ReactiveState . coAutoRun [common] fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. decrement [common] fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . derived [common] fun < T > derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. derivedWhileSubscribed [common] fun < T > derivedWhileSubscribed (initial: T , flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. DisposableGroup [common] fun DisposableGroup (): DisposableGroup Constructs a DisposableGroup . disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). EventNotifier [common] fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > Creates an EventNotifier . get [common] fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used. [common] fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope ). getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name. handleEvents [common] suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . increment [common] fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom [common] suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher . [common] fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineContext . [common] fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineScope. isFatal [common, jvmCommon, nonJvm] [common] expect fun Throwable . isFatal (): Boolean [jvmCommon, nonJvm] actual fun Throwable . isFatal (): Boolean latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest. lazyProperty [common] fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > A helper for creating a lazily computed ReadOnlyProperty based on a KProperty . MutableFlow [common] fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > Creates a MutableFlow . MutableValueFlow [common] fun < T > MutableValueFlow (value: T , setter: (value: T ) -> Unit ? = null): MutableValueFlow < T > Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations. propertyName [common] inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > A lazyProperty that only receives the KProperty.name as its argument. replace [common] fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. runCatchingNonFatal [common] inline fun < T > runCatchingNonFatal (block: () -> T ): Result < T > Similar to the stdlib runCatching , but uses throwIfFatal to re-throw fatal exceptions immediately. SuspendMutableValueFlow [common] @ ExperimentalReactiveStateApi fun < T > SuspendMutableValueFlow (value: T , setter: suspend (value: T ) -> Unit ): SuspendMutableValueFlow < T > throwIfFatal [common] inline fun < T : Throwable > T . throwIfFatal (): T Throws this exception if it\u2019s fatal. Otherwise returns it. validUntil [common] fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > Creates an automatically invalidated property. withErrorReporting [common] inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) Executes the given block , catching any errors and reporting them to the given eventNotifier . [common] inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) Executes the given block , catching any errors and calling onError , but handling CancellationException. withSetter [common] fun < T > MutableStateFlow< T >. withSetter (setter: MutableStateFlow< T >.( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter instead of doing the actual value update.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/#properties","text":"Name Summary dispatchers [common] var dispatchers : CoroutineDispatcherConfig The currently active CoroutineDispatcherConfig .","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableGroup DisposableGroup \u00b6 [common]\\ fun DisposableGroup (): DisposableGroup Constructs a DisposableGroup .","title":" disposable group"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/#disposablegroup","text":"[common]\\ fun DisposableGroup (): DisposableGroup Constructs a DisposableGroup .","title":"DisposableGroup"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/","text":"// reactivestate-core / com.ensody.reactivestate / EventNotifier EventNotifier \u00b6 [common]\\ fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > Creates an EventNotifier .","title":" event notifier"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/#eventnotifier","text":"[common]\\ fun < T > EventNotifier (capacity: Int = Channel.UNLIMITED): EventNotifier < T > Creates an EventNotifier .","title":"EventNotifier"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/","text":"// reactivestate-core / com.ensody.reactivestate / MutableFlow MutableFlow \u00b6 [common]\\ fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > Creates a MutableFlow .","title":" mutable flow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/#mutableflow","text":"[common]\\ fun < T > MutableFlow (capacity: Int = Channel.RENDEZVOUS, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableFlow < T > Creates a MutableFlow .","title":"MutableFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/","text":"// reactivestate-core / com.ensody.reactivestate / MutableValueFlow MutableValueFlow \u00b6 [common]\\ fun < T > MutableValueFlow (value: T , setter: (value: T ) -> Unit ? = null): MutableValueFlow < T > Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations.","title":" mutable value flow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/#mutablevalueflow","text":"[common]\\ fun < T > MutableValueFlow (value: T , setter: (value: T ) -> Unit ? = null): MutableValueFlow < T > Instantiates a MutableValueFlow with the given initial value and optional setter to intercept mutations.","title":"MutableValueFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/","text":"// reactivestate-core / com.ensody.reactivestate / SuspendMutableValueFlow SuspendMutableValueFlow \u00b6 [common]\\ @ ExperimentalReactiveStateApi fun < T > SuspendMutableValueFlow (value: T , setter: suspend (value: T ) -> Unit ): SuspendMutableValueFlow < T >","title":" suspend mutable value flow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/#suspendmutablevalueflow","text":"[common]\\ @ ExperimentalReactiveStateApi fun < T > SuspendMutableValueFlow (value: T , setter: suspend (value: T ) -> Unit ): SuspendMutableValueFlow < T >","title":"SuspendMutableValueFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/add-delay/","text":"// reactivestate-core / com.ensody.reactivestate / addDelay addDelay \u00b6 [common]\\ fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op.","title":"Add delay"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/add-delay/#adddelay","text":"[common]\\ fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op.","title":"addDelay"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/after-update/","text":"// reactivestate-core / com.ensody.reactivestate / afterUpdate afterUpdate \u00b6 [common]\\ fun < T > MutableStateFlow< T >. afterUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter after doing the actual value update. The value is set automatically for you before setter has been called. For more control use withSetter . This can be used to wrap a MutableStateFlow with extra update logic.","title":"After update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/after-update/#afterupdate","text":"[common]\\ fun < T > MutableStateFlow< T >. afterUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter after doing the actual value update. The value is set automatically for you before setter has been called. For more control use withSetter . This can be used to wrap a MutableStateFlow with extra update logic.","title":"afterUpdate"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/attach-to/","text":"// reactivestate-core / com.ensody.reactivestate / attachTo attachTo \u00b6 [common]\\ fun ReactiveState <out ErrorEvents >. attachTo (owner: Any )","title":"Attach to"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/attach-to/#attachto","text":"[common]\\ fun ReactiveState <out ErrorEvents >. attachTo (owner: Any )","title":"attachTo"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/auto-run/","text":"// reactivestate-core / com.ensody.reactivestate / autoRun autoRun \u00b6 [common]\\ fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details. Parameters \u00b6 common onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [common]\\ fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Auto run"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/auto-run/#autorun","text":"[common]\\ fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details.","title":"autoRun"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/auto-run/#parameters","text":"common onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables. [common]\\ fun CoroutineScope. autoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/auto-run/#parameters_1","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/before-update/","text":"// reactivestate-core / com.ensody.reactivestate / beforeUpdate beforeUpdate \u00b6 [common]\\ fun < T > MutableStateFlow< T >. beforeUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter before doing the actual value update. The value is set automatically for you after setter has been called. For more control use withSetter . This can be used to wrap a MutableStateFlow with extra update logic.","title":"Before update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/before-update/#beforeupdate","text":"[common]\\ fun < T > MutableStateFlow< T >. beforeUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter before doing the actual value update. The value is set automatically for you after setter has been called. For more control use withSetter . This can be used to wrap a MutableStateFlow with extra update logic.","title":"beforeUpdate"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/child-reactive-state/","text":"// reactivestate-core / com.ensody.reactivestate / childReactiveState childReactiveState \u00b6 [common]\\ fun < E : ErrorEvents , P : ReactiveState <out E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > Creates and attaches a child ReactiveState . This merges the child\u2019s ReactiveState.eventNotifier and ReactiveState.loading into the parent. Example: // The parent has to also implement the child events interface ParentEvents : ChildEvents { fun onSomeEvent () } class ParentViewModel ( scope : CoroutineScope ) : BaseReactiveState < ParentEvents > ( scope ) { val childViewModel by childReactiveState { ChildViewModel ( scope ) } } interface ChildEvents : ErrorEvents { fun onSomeChildEvent () } class ChildViewModel ( scope : CoroutineScope ) : BaseReactiveState < ChildEvents > ( scope ) { init { launch { // ... eventNotifier { onSomeChildEvent () } } } }","title":"Child reactive state"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/child-reactive-state/#childreactivestate","text":"[common]\\ fun < E : ErrorEvents , P : ReactiveState <out E >, RS : ReactiveState < E >> P . childReactiveState (block: () -> RS ): ReadOnlyProperty < Any ?, RS > Creates and attaches a child ReactiveState . This merges the child\u2019s ReactiveState.eventNotifier and ReactiveState.loading into the parent. Example: // The parent has to also implement the child events interface ParentEvents : ChildEvents { fun onSomeEvent () } class ParentViewModel ( scope : CoroutineScope ) : BaseReactiveState < ParentEvents > ( scope ) { val childViewModel by childReactiveState { ChildViewModel ( scope ) } } interface ChildEvents : ErrorEvents { fun onSomeChildEvent () } class ChildViewModel ( scope : CoroutineScope ) : BaseReactiveState < ChildEvents > ( scope ) { init { launch { // ... eventNotifier { onSomeChildEvent () } } } }","title":"childReactiveState"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/co-auto-run/","text":"// reactivestate-core / com.ensody.reactivestate / coAutoRun coAutoRun \u00b6 [common]\\ fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details. Parameters \u00b6 common onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common]\\ fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . observer The callback which is used to track the observables.","title":"Co auto run"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/co-auto-run/#coautorun","text":"[common]\\ fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineLauncher \u2018s scope completes. See AutoRunner for more details.","title":"coAutoRun"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/co-auto-run/#parameters","text":"common onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common]\\ fun CoroutineScope. coAutoRun (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is a convenience function that immediately starts the AutoRunner.run cycle for you. Returns the underlying AutoRunner . To stop watching, you should call AutoRunner.dispose. The AutoRunner is automatically disposed when the CoroutineScope completes. See AutoRunner for more details.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/co-auto-run/#parameters_1","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. If you provide a handler you have to manually call run . flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-map/","text":"// reactivestate-core / com.ensody.reactivestate / conflatedMap conflatedMap \u00b6 [common]\\ inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. Maps first and last element and intermediate when possible. The first map starts immediately and we throw away all intermediate changes until the computation is finished and then we map again for the last change that happened in the meantime. Parameters \u00b6 common timeoutMillis Additional delay before the last element is mapped (throwing away intermediate elements).","title":"Conflated map"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-map/#conflatedmap","text":"[common]\\ inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. Maps first and last element and intermediate when possible. The first map starts immediately and we throw away all intermediate changes until the computation is finished and then we map again for the last change that happened in the meantime.","title":"conflatedMap"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-map/#parameters","text":"common timeoutMillis Additional delay before the last element is mapped (throwing away intermediate elements).","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-transform/","text":"// reactivestate-core / com.ensody.reactivestate / conflatedTransform conflatedTransform \u00b6 [common]\\ inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element.","title":"Conflated transform"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-transform/#conflatedtransform","text":"[common]\\ inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element.","title":"conflatedTransform"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-worker/","text":"// reactivestate-core / com.ensody.reactivestate / conflatedWorker conflatedWorker \u00b6 [common]\\ fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . Computes first and last element and intermediate when possible. The first computation starts immediately and we throw away all intermediate changes until the computation is finished and then recompute again for the last change that happened in the meantime. This is useful e.g. when you have a constant stream of events (e.g. WebSocket change notifications, keyboard input, mouse moved, etc.) and you want to show intermediate results. If you only want to show the latest result you can use latestWorker . Parameters \u00b6 common timeoutMillis Additional delay before the last element is computed (throwing away intermediate elements).","title":"Conflated worker"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-worker/#conflatedworker","text":"[common]\\ fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . Computes first and last element and intermediate when possible. The first computation starts immediately and we throw away all intermediate changes until the computation is finished and then recompute again for the last change that happened in the meantime. This is useful e.g. when you have a constant stream of events (e.g. WebSocket change notifications, keyboard input, mouse moved, etc.) and you want to show intermediate results. If you only want to show the latest result you can use latestWorker .","title":"conflatedWorker"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/conflated-worker/#parameters","text":"common timeoutMillis Additional delay before the last element is computed (throwing away intermediate elements).","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/debounce-worker/","text":"// reactivestate-core / com.ensody.reactivestate / debounceWorker debounceWorker \u00b6 [common]\\ fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker . Parameters \u00b6 common timeoutMillis The debounce timeout.","title":"Debounce worker"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/debounce-worker/#debounceworker","text":"[common]\\ fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker .","title":"debounceWorker"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/debounce-worker/#parameters","text":"common timeoutMillis The debounce timeout.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/decrement/","text":"// reactivestate-core / com.ensody.reactivestate / decrement decrement \u00b6 [common]\\ fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount .","title":"Decrement"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/decrement/#decrement","text":"[common]\\ fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount .","title":"decrement"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/derived-while-subscribed/","text":"// reactivestate-core / com.ensody.reactivestate / derivedWhileSubscribed derivedWhileSubscribed \u00b6 [common]\\ fun < T > derivedWhileSubscribed (initial: T , flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. This doesn\u2019t need a CoroutineScope/ CoroutineLauncher and has SharingStarted.WhileSubscribed behavior. If you have access to a CoroutineScope/ CoroutineLauncher you should better use the normal derived functions. Parameters \u00b6 common initial The initial value (until the first computation finishes). flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to null . observer The callback which is used to track the observables.","title":"Derived while subscribed"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/derived-while-subscribed/#derivedwhilesubscribed","text":"[common]\\ fun < T > derivedWhileSubscribed (initial: T , flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. This doesn\u2019t need a CoroutineScope/ CoroutineLauncher and has SharingStarted.WhileSubscribed behavior. If you have access to a CoroutineScope/ CoroutineLauncher you should better use the normal derived functions.","title":"derivedWhileSubscribed"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/derived-while-subscribed/#parameters","text":"common initial The initial value (until the first computation finishes). flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to null . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/derived/","text":"// reactivestate-core / com.ensody.reactivestate / derived derived \u00b6 [common]\\ fun < T > derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. This doesn\u2019t need a CoroutineScope/ CoroutineLauncher and has SharingStarted.WhileSubscribed behavior. If you have access to a CoroutineScope/ CoroutineLauncher you should better use the normal derived functions. [common]\\ fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [common]\\ fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed. Parameters \u00b6 common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common]\\ fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed. Parameters \u00b6 common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to null . observer The callback which is used to track the observables.","title":"Derived"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/derived/#derived","text":"[common]\\ fun < T > derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. This doesn\u2019t need a CoroutineScope/ CoroutineLauncher and has SharingStarted.WhileSubscribed behavior. If you have access to a CoroutineScope/ CoroutineLauncher you should better use the normal derived functions. [common]\\ fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > fun < T > CoroutineScope. derived (launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. This behaves like SharingStarted.Eagerly and computes the initial value by executing the observer function immediately. [common]\\ fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed.","title":"derived"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/derived/#parameters","text":"common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. [common]\\ fun < T > CoroutineScope. derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, launcher: CoroutineLauncher = SimpleCoroutineLauncher(this), flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = null, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. You can use this to compute values on-demand only via SharingStarted.WhileSubscribed.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/derived/#parameters_1","text":"common initial The initial value (until the first computation finishes). started When the value should be updated. Pass SharingStarted.WhileSubscribed to compute only on demand. Defaults to SharingStarted.Eagerly. launcher The CoroutineLauncher to use. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to null . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/dispatchers/","text":"// reactivestate-core / com.ensody.reactivestate / dispatchers dispatchers \u00b6 [common]\\ var dispatchers : CoroutineDispatcherConfig The currently active CoroutineDispatcherConfig .","title":"Dispatchers"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/dispatchers/#dispatchers","text":"[common]\\ var dispatchers : CoroutineDispatcherConfig The currently active CoroutineDispatcherConfig .","title":"dispatchers"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/dispose-on-completion-of/","text":"// reactivestate-core / com.ensody.reactivestate / disposeOnCompletionOf disposeOnCompletionOf \u00b6 [common]\\ fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common]\\ fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common]\\ fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common]\\ fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Dispose on completion of"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/dispose-on-completion-of/#disposeoncompletionof","text":"[common]\\ fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common]\\ fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common]\\ fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common]\\ fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"disposeOnCompletionOf"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/get-data/","text":"// reactivestate-core / com.ensody.reactivestate / getData getData \u00b6 [common]\\ fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Get data"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/get-data/#getdata","text":"[common]\\ fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"getData"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/get/","text":"// reactivestate-core / com.ensody.reactivestate / get get \u00b6 [common]\\ fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope ). [common]\\ fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used.","title":"Get"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/get/#get","text":"[common]\\ fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope ). [common]\\ fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used.","title":"get"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/handle-events/","text":"// reactivestate-core / com.ensody.reactivestate / handleEvents handleEvents \u00b6 [common]\\ suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . Any errors during event handling will trigger ErrorEvents.onError on the handler .","title":"Handle events"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/handle-events/#handleevents","text":"[common]\\ suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . Any errors during event handling will trigger ErrorEvents.onError on the handler .","title":"handleEvents"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/increment-from/","text":"// reactivestate-core / com.ensody.reactivestate / incrementFrom incrementFrom \u00b6 [common]\\ suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . For example, if this MutableValueFlow is initially set to 1 and flow is set to 1, 2, 0 then the value of this MutableValueFlow will be set to 2, then 3, then 1.","title":"Increment from"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/increment-from/#incrementfrom","text":"[common]\\ suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . For example, if this MutableValueFlow is initially set to 1 and flow is set to 1, 2, 0 then the value of this MutableValueFlow will be set to 2, then 3, then 1.","title":"incrementFrom"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/increment/","text":"// reactivestate-core / com.ensody.reactivestate / increment increment \u00b6 [common]\\ fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount .","title":"Increment"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/increment/#increment","text":"[common]\\ fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount .","title":"increment"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/invoke-on-completion/","text":"// reactivestate-core / com.ensody.reactivestate / invokeOnCompletion invokeOnCompletion \u00b6 [common]\\ fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineContext . [common]\\ fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineScope. [common]\\ fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Invoke on completion"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/invoke-on-completion/#invokeoncompletion","text":"[common]\\ fun CoroutineContext . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineContext . [common]\\ fun CoroutineScope. invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineScope. [common]\\ fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"invokeOnCompletion"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/is-fatal/","text":"// reactivestate-core / com.ensody.reactivestate / isFatal isFatal \u00b6 [common, jvmCommon, nonJvm]\\ [common]\\ expect fun Throwable . isFatal (): Boolean [jvmCommon, nonJvm]\\ actual fun Throwable . isFatal (): Boolean","title":"Is fatal"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/is-fatal/#isfatal","text":"[common, jvmCommon, nonJvm]\\ [common]\\ expect fun Throwable . isFatal (): Boolean [jvmCommon, nonJvm]\\ actual fun Throwable . isFatal (): Boolean","title":"isFatal"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/latest-worker/","text":"// reactivestate-core / com.ensody.reactivestate / latestWorker latestWorker \u00b6 [common]\\ fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker . Parameters \u00b6 common timeoutMillis The debounce timeout.","title":"Latest worker"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/latest-worker/#latestworker","text":"[common]\\ fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest. Warning: This will not compute anything if new entries keep coming in at a rate faster than timeoutMillis ! This also adds a delay before the first execution! Especially in UIs you\u2019ll usually want to: execute as quickly as possible, so that the UI feels snappy get intermediate results to provide some feedback This is why you\u2019ll usually want to use conflatedWorker .","title":"latestWorker"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/latest-worker/#parameters","text":"common timeoutMillis The debounce timeout.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/lazy-property/","text":"// reactivestate-core / com.ensody.reactivestate / lazyProperty lazyProperty \u00b6 [common]\\ fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > A helper for creating a lazily computed ReadOnlyProperty based on a KProperty .","title":"Lazy property"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/lazy-property/#lazyproperty","text":"[common]\\ fun < T > lazyProperty (block: (property: KProperty <*>) -> T ): ReadOnlyProperty < Any ?, T > A helper for creating a lazily computed ReadOnlyProperty based on a KProperty .","title":"lazyProperty"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/property-name/","text":"// reactivestate-core / com.ensody.reactivestate / propertyName propertyName \u00b6 [common]\\ inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > A lazyProperty that only receives the KProperty.name as its argument.","title":"Property name"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/property-name/#propertyname","text":"[common]\\ inline fun < T > propertyName (crossinline block: (name: String ) -> T ): ReadOnlyProperty < Any ?, T > A lazyProperty that only receives the KProperty.name as its argument.","title":"propertyName"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/replace/","text":"// reactivestate-core / com.ensody.reactivestate / replace replace \u00b6 [common]\\ fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. WARNING: This method is not thread-safe! Use MutableValueFlow.replaceLocked if you want to guarantee correctness under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo ( val num : Int ) val stateFlow = MutableStateFlow ( Foo ( 3 )) stateFlow . replace { copy ( num = 5 ) } Return \u00b6 The previous value before replacing.","title":"Replace"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/replace/#replace","text":"[common]\\ fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. WARNING: This method is not thread-safe! Use MutableValueFlow.replaceLocked if you want to guarantee correctness under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo ( val num : Int ) val stateFlow = MutableStateFlow ( Foo ( 3 )) stateFlow . replace { copy ( num = 5 ) }","title":"replace"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/replace/#return","text":"The previous value before replacing.","title":"Return"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/run-catching-non-fatal/","text":"// reactivestate-core / com.ensody.reactivestate / runCatchingNonFatal runCatchingNonFatal \u00b6 [common]\\ inline fun < T > runCatchingNonFatal (block: () -> T ): Result < T > Similar to the stdlib runCatching , but uses throwIfFatal to re-throw fatal exceptions immediately.","title":"Run catching non fatal"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/run-catching-non-fatal/#runcatchingnonfatal","text":"[common]\\ inline fun < T > runCatchingNonFatal (block: () -> T ): Result < T > Similar to the stdlib runCatching , but uses throwIfFatal to re-throw fatal exceptions immediately.","title":"runCatchingNonFatal"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/throw-if-fatal/","text":"// reactivestate-core / com.ensody.reactivestate / throwIfFatal throwIfFatal \u00b6 [common]\\ inline fun < T : Throwable > T . throwIfFatal (): T Throws this exception if it\u2019s fatal. Otherwise returns it.","title":"Throw if fatal"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/throw-if-fatal/#throwiffatal","text":"[common]\\ inline fun < T : Throwable > T . throwIfFatal (): T Throws this exception if it\u2019s fatal. Otherwise returns it.","title":"throwIfFatal"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/valid-until/","text":"// reactivestate-core / com.ensody.reactivestate / validUntil validUntil \u00b6 [common]\\ fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > Creates an automatically invalidated property. The property starts out invalid and must be set to become valid. When it becomes invalidated you have to set it, again, to make it valid. The property is invalidated when the provided invalidateOn function calls the lambda function passed as its first argument. Example: class SomeClass { var value by validUntil < String > { invalidate -> onSomeEvent { invalidate () } } } Android-specific example: class MainFragment : Fragment () { private var binding by validUntil < MainFragmentBinding > ( :: onDestroyView ) override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle? ): View { binding = MainFragmentBinding . inflate ( inflater , container , false ) val username = binding . username // ... return binding . root } }","title":"Valid until"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/valid-until/#validuntil","text":"[common]\\ fun < T > validUntil (invalidateOn: (invalidate: () -> Unit ) -> Any ?): ReadWriteProperty < Any ?, T > Creates an automatically invalidated property. The property starts out invalid and must be set to become valid. When it becomes invalidated you have to set it, again, to make it valid. The property is invalidated when the provided invalidateOn function calls the lambda function passed as its first argument. Example: class SomeClass { var value by validUntil < String > { invalidate -> onSomeEvent { invalidate () } } } Android-specific example: class MainFragment : Fragment () { private var binding by validUntil < MainFragmentBinding > ( :: onDestroyView ) override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup?, savedInstanceState : Bundle? ): View { binding = MainFragmentBinding . inflate ( inflater , container , false ) val username = binding . username // ... return binding . root } }","title":"validUntil"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/with-error-reporting/","text":"// reactivestate-core / com.ensody.reactivestate / withErrorReporting withErrorReporting \u00b6 [common]\\ suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) Executes the given block , catching any errors and reporting them to the given eventNotifier . [common]\\ inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) Executes the given block , catching any errors and calling onError , but handling CancellationException.","title":"With error reporting"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/with-error-reporting/#witherrorreporting","text":"[common]\\ suspend fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, onError: suspend (error: Throwable ) -> Unit ?, block: suspend () -> Unit ) inline fun < E : ErrorEvents > withErrorReporting (eventNotifier: EventNotifier < E >, block: () -> Unit ) Executes the given block , catching any errors and reporting them to the given eventNotifier . [common]\\ inline fun withErrorReporting (onError: (error: Throwable ) -> Unit , block: () -> Unit ) Executes the given block , catching any errors and calling onError , but handling CancellationException.","title":"withErrorReporting"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/with-setter/","text":"// reactivestate-core / com.ensody.reactivestate / withSetter withSetter \u00b6 [common]\\ fun < T > MutableStateFlow< T >. withSetter (setter: MutableStateFlow< T >.( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter instead of doing the actual value update. IMPORTANT: You must manually set value = on the underlying MutableStateFlow. The setter gets the underlying MutableStateFlow via this . This can be used to wrap a MutableStateFlow with extra update logic. For simpler use cases you might prefer withSetter instead.","title":"With setter"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/with-setter/#withsetter","text":"[common]\\ fun < T > MutableStateFlow< T >. withSetter (setter: MutableStateFlow< T >.( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter instead of doing the actual value update. IMPORTANT: You must manually set value = on the underlying MutableStateFlow. The setter gets the underlying MutableStateFlow via this . This can be used to wrap a MutableStateFlow with extra update logic. For simpler use cases you might prefer withSetter instead.","title":"withSetter"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/","text":"// reactivestate-core / com.ensody.reactivestate / AttachedDisposables AttachedDisposables \u00b6 [common]\\ interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposable s attached to it, so they are automatically disposed together with this object. Functions \u00b6 Name Summary dispose [common] open override fun dispose () Default implementation disposing the attachedDisposables . Properties \u00b6 Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. Inheritors \u00b6 Name BaseAutoRunner Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/#attacheddisposables","text":"[common]\\ interface AttachedDisposables : DisposableHandle A Disposable that can have additional Disposable s attached to it, so they are automatically disposed together with this object.","title":"AttachedDisposables"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/#functions","text":"Name Summary dispose [common] open override fun dispose () Default implementation disposing the attachedDisposables .","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/#properties","text":"Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/#inheritors","text":"Name BaseAutoRunner","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/attached-disposables/","text":"// reactivestate-core / com.ensody.reactivestate / AttachedDisposables / attachedDisposables attachedDisposables \u00b6 [common]\\ abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"Attached disposables"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/attached-disposables/#attacheddisposables","text":"[common]\\ abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"attachedDisposables"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/dispose/","text":"// reactivestate-core / com.ensody.reactivestate / AttachedDisposables / dispose dispose \u00b6 [common]\\ open override fun dispose () Default implementation disposing the attachedDisposables .","title":"Dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-attached-disposables/dispose/#dispose","text":"[common]\\ open override fun dispose () Default implementation disposing the attachedDisposables .","title":"dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / AutoRunner AutoRunner \u00b6 [common]\\ class AutoRunner < T >(val launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the synchronous version. See CoAutoRunner for the suspension function based version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . observer The callback which is used to track the observables. Constructors \u00b6 AutoRunner [common] fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >) Functions \u00b6 Name Summary dispose [common] open override fun dispose () Stops watching observables. run [common] fun run (): T Calls observer and tracks its dependencies. triggerChange [common] open override fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/#autorunner","text":"[common]\\ class AutoRunner < T >(val launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the synchronous version. See CoAutoRunner for the suspension function based version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper.","title":"AutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/#constructors","text":"AutoRunner [common] fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >)","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/#functions","text":"Name Summary dispose [common] open override fun dispose () Stops watching observables. run [common] fun run (): T Calls observer and tracks its dependencies. triggerChange [common] open override fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / AutoRunner / AutoRunner AutoRunner \u00b6 [common]\\ fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >) Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . observer The callback which is used to track the observables.","title":" auto runner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/-auto-runner/#autorunner","text":"[common]\\ fun AutoRunner (launcher: CoroutineLauncher , onChange: AutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, observer: AutoRunCallback < T >)","title":"AutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/run/","text":"// reactivestate-core / com.ensody.reactivestate / AutoRunner / run run \u00b6 [common]\\ fun run (): T Calls observer and tracks its dependencies.","title":"Run"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner/run/#run","text":"[common]\\ fun run (): T Calls observer and tracks its dependencies.","title":"run"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/","text":"// reactivestate-core / com.ensody.reactivestate / AutoRunnerObservable AutoRunnerObservable \u00b6 [common]\\ interface AutoRunnerObservable < T > Base interface for observing a hard-coded AutoRunner instance. You can use this to wrap actual observables (e.g. Android\u2019s LiveData ). Functions \u00b6 Name Summary addObserver [common] abstract fun addObserver () removeObserver [common] abstract fun removeObserver () Properties \u00b6 Name Summary value [common] abstract val value : T","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/#autorunnerobservable","text":"[common]\\ interface AutoRunnerObservable < T > Base interface for observing a hard-coded AutoRunner instance. You can use this to wrap actual observables (e.g. Android\u2019s LiveData ).","title":"AutoRunnerObservable"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/#functions","text":"Name Summary addObserver [common] abstract fun addObserver () removeObserver [common] abstract fun removeObserver ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/#properties","text":"Name Summary value [common] abstract val value : T","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/add-observer/","text":"// reactivestate-core / com.ensody.reactivestate / AutoRunnerObservable / addObserver addObserver \u00b6 [common]\\ abstract fun addObserver ()","title":"Add observer"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/add-observer/#addobserver","text":"[common]\\ abstract fun addObserver ()","title":"addObserver"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/remove-observer/","text":"// reactivestate-core / com.ensody.reactivestate / AutoRunnerObservable / removeObserver removeObserver \u00b6 [common]\\ abstract fun removeObserver ()","title":"Remove observer"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/remove-observer/#removeobserver","text":"[common]\\ abstract fun removeObserver ()","title":"removeObserver"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/value/","text":"// reactivestate-core / com.ensody.reactivestate / AutoRunnerObservable / value value \u00b6 [common]\\ abstract val value : T","title":"Value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-auto-runner-observable/value/#value","text":"[common]\\ abstract val value : T","title":"value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / BaseAutoRunner BaseAutoRunner \u00b6 [common]\\ abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . No generic types. Constructors \u00b6 BaseAutoRunner [common] fun BaseAutoRunner () Functions \u00b6 Name Summary dispose [common] open override fun dispose () Default implementation disposing the attachedDisposables . triggerChange [common] abstract fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] abstract val launcher : CoroutineLauncher Inheritors \u00b6 Name InternalBaseAutoRunner Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/#baseautorunner","text":"[common]\\ abstract class BaseAutoRunner : AttachedDisposables Just the minimum interface needed for Resolver . No generic types.","title":"BaseAutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/#constructors","text":"BaseAutoRunner [common] fun BaseAutoRunner ()","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/#functions","text":"Name Summary dispose [common] open override fun dispose () Default implementation disposing the attachedDisposables . triggerChange [common] abstract fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/#properties","text":"Name Summary attachedDisposables [common] abstract val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] abstract val launcher : CoroutineLauncher","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/#inheritors","text":"Name InternalBaseAutoRunner","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/-base-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / BaseAutoRunner / BaseAutoRunner BaseAutoRunner \u00b6 [common]\\ fun BaseAutoRunner ()","title":" base auto runner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/-base-auto-runner/#baseautorunner","text":"[common]\\ fun BaseAutoRunner ()","title":"BaseAutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/launcher/","text":"// reactivestate-core / com.ensody.reactivestate / BaseAutoRunner / launcher launcher \u00b6 [common]\\ abstract val launcher : CoroutineLauncher","title":"Launcher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/launcher/#launcher","text":"[common]\\ abstract val launcher : CoroutineLauncher","title":"launcher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/trigger-change/","text":"// reactivestate-core / com.ensody.reactivestate / BaseAutoRunner / triggerChange triggerChange \u00b6 [common]\\ abstract fun triggerChange ()","title":"Trigger change"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-auto-runner/trigger-change/#triggerchange","text":"[common]\\ abstract fun triggerChange ()","title":"triggerChange"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/","text":"// reactivestate-core / com.ensody.reactivestate / BaseReactiveState BaseReactiveState \u00b6 [common]\\ open class BaseReactiveState < E : ErrorEvents >(scope: CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling. Example: // You can compose multiple events interfaces with simple inheritance (more elegant than sealed classes) interface FooEvents : ErrorEvents , OtherEvents , AndMoreEvents { fun onUserIsUnauthorized () } class FooViewModel ( scope : CoroutineScope ) : BaseReactiveState < FooEvents > ( scope ) { private val _messages = MutableStateFlow < List < Message >> ( emptyList ()) val messages : StateFlow < List < Messages >> = _messages init { loadMessages () } fun loadMessages () { launch { // Let's pretend this function returns null for unauthorized requests val messages = retrieveMessagesFromBackend () if ( messages == null ) { eventNotifier { onUserIsUnauthorized () } } else { _messages . value = messages } } } } Constructors \u00b6 BaseReactiveState [common] fun BaseReactiveState (scope: CoroutineScope) Functions \u00b6 Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open override fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors. Properties \u00b6 Name Summary eventNotifier [common] open override val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int > The default loading tracker. Extensions \u00b6 Name Summary attachTo [common] fun ReactiveState <out ErrorEvents >. attachTo (owner: Any ) autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/#basereactivestate","text":"[common]\\ open class BaseReactiveState < E : ErrorEvents >(scope: CoroutineScope) : SimpleCoroutineLauncher , ReactiveState < E > Base class/delegate for ViewModels and other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling. Example: // You can compose multiple events interfaces with simple inheritance (more elegant than sealed classes) interface FooEvents : ErrorEvents , OtherEvents , AndMoreEvents { fun onUserIsUnauthorized () } class FooViewModel ( scope : CoroutineScope ) : BaseReactiveState < FooEvents > ( scope ) { private val _messages = MutableStateFlow < List < Message >> ( emptyList ()) val messages : StateFlow < List < Messages >> = _messages init { loadMessages () } fun loadMessages () { launch { // Let's pretend this function returns null for unauthorized requests val messages = retrieveMessagesFromBackend () if ( messages == null ) { eventNotifier { onUserIsUnauthorized () } } else { _messages . value = messages } } } }","title":"BaseReactiveState"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/#constructors","text":"BaseReactiveState [common] fun BaseReactiveState (scope: CoroutineScope)","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/#functions","text":"Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open override fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/#properties","text":"Name Summary eventNotifier [common] open override val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int > The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/#extensions","text":"Name Summary attachTo [common] fun ReactiveState <out ErrorEvents >. attachTo (owner: Any ) autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/-base-reactive-state/","text":"// reactivestate-core / com.ensody.reactivestate / BaseReactiveState / BaseReactiveState BaseReactiveState \u00b6 [common]\\ fun BaseReactiveState (scope: CoroutineScope)","title":" base reactive state"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/-base-reactive-state/#basereactivestate","text":"[common]\\ fun BaseReactiveState (scope: CoroutineScope)","title":"BaseReactiveState"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/event-notifier/","text":"// reactivestate-core / com.ensody.reactivestate / BaseReactiveState / eventNotifier eventNotifier \u00b6 [common]\\ open override val eventNotifier : EventNotifier < E >","title":"Event notifier"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/event-notifier/#eventnotifier","text":"[common]\\ open override val eventNotifier : EventNotifier < E >","title":"eventNotifier"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/on-error/","text":"// reactivestate-core / com.ensody.reactivestate / BaseReactiveState / onError onError \u00b6 [common]\\ open override fun onError (error: Throwable )","title":"On error"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-reactive-state/on-error/#onerror","text":"[common]\\ open override fun onError (error: Throwable )","title":"onError"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/","text":"// reactivestate-core / com.ensody.reactivestate / BaseSuspendMutableValueFlow BaseSuspendMutableValueFlow \u00b6 [common]\\ @ ExperimentalReactiveStateApi abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value. This is useful e.g. for values backed by some storage/backend system. See also \u00b6 common SuspendMutableValueFlow for a simple lambda-based implementation. Constructors \u00b6 BaseSuspendMutableValueFlow [common] fun < T > BaseSuspendMutableValueFlow (value: T ) Functions \u00b6 Name Summary collect [common] open suspend override fun collect (collector: FlowCollector< T >): Nothing replace [common] open suspend override fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set [common] open suspend override fun set (value: T , force: Boolean ) Assigns a new value . update [common] open suspend override fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg. updateThis [common] open suspend override fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this. Properties \u00b6 Name Summary replayCache [common] open override val replayCache : List < T > value [common] open override val value : T Extensions \u00b6 Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#basesuspendmutablevalueflow","text":"[common]\\ @ ExperimentalReactiveStateApi abstract class BaseSuspendMutableValueFlow < T > : ValueFlow < T > , SuspendMutableValueFlow < T > Base class for StateFlows that can be mutated only via suspend functions - in contrast to assigning the value. This is useful e.g. for values backed by some storage/backend system.","title":"BaseSuspendMutableValueFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#see-also","text":"common SuspendMutableValueFlow for a simple lambda-based implementation.","title":"See also"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#constructors","text":"BaseSuspendMutableValueFlow [common] fun < T > BaseSuspendMutableValueFlow (value: T )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#functions","text":"Name Summary collect [common] open suspend override fun collect (collector: FlowCollector< T >): Nothing replace [common] open suspend override fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set [common] open suspend override fun set (value: T , force: Boolean ) Assigns a new value . update [common] open suspend override fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg. updateThis [common] open suspend override fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#properties","text":"Name Summary replayCache [common] open override val replayCache : List < T > value [common] open override val value : T","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/#extensions","text":"Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/-base-suspend-mutable-value-flow/","text":"// reactivestate-core / com.ensody.reactivestate / BaseSuspendMutableValueFlow / BaseSuspendMutableValueFlow BaseSuspendMutableValueFlow \u00b6 [common]\\ fun < T > BaseSuspendMutableValueFlow (value: T )","title":" base suspend mutable value flow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/-base-suspend-mutable-value-flow/#basesuspendmutablevalueflow","text":"[common]\\ fun < T > BaseSuspendMutableValueFlow (value: T )","title":"BaseSuspendMutableValueFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/replace/","text":"// reactivestate-core / com.ensody.reactivestate / BaseSuspendMutableValueFlow / replace replace \u00b6 [common]\\ open suspend override fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value.","title":"Replace"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/replace/#replace","text":"[common]\\ open suspend override fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value.","title":"replace"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/set/","text":"// reactivestate-core / com.ensody.reactivestate / BaseSuspendMutableValueFlow / set set \u00b6 [common]\\ open suspend override fun set (value: T , force: Boolean ) Assigns a new value . Parameters \u00b6 common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false , behaving like MutableStateFlow.","title":"Set"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/set/#set","text":"[common]\\ open suspend override fun set (value: T , force: Boolean ) Assigns a new value .","title":"set"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/set/#parameters","text":"common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false , behaving like MutableStateFlow.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update-this/","text":"// reactivestate-core / com.ensody.reactivestate / BaseSuspendMutableValueFlow / updateThis updateThis \u00b6 [common]\\ open suspend override fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Update this"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update-this/#updatethis","text":"[common]\\ open suspend override fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"updateThis"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update/","text":"// reactivestate-core / com.ensody.reactivestate / BaseSuspendMutableValueFlow / update update \u00b6 [common]\\ open suspend override fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"Update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-base-suspend-mutable-value-flow/update/#update","text":"[common]\\ open suspend override fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / CoAutoRunner CoAutoRunner \u00b6 [common]\\ class CoAutoRunner < T >(val launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the suspension function based version. See AutoRunner for the synchronous version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper. Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables. Constructors \u00b6 CoAutoRunner [common] fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) Functions \u00b6 Name Summary dispose [common] open override fun dispose () Stops watching observables. run [common] suspend fun run (): T Calls observer and tracks its dependencies. triggerChange [common] open override fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/#coautorunner","text":"[common]\\ class CoAutoRunner < T >(val launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) : InternalBaseAutoRunner Watches observables for changes. Often useful to keep things in sync (e.g. ViewModel -> UI). This is the suspension function based version. See AutoRunner for the synchronous version. Given an observer, this class will automatically register itself as a listener and keep track of the observables which observer depends on. You have to call run once to start watching. To stop watching, you should call dispose. Instead of instantiating an AutoRunner directly you\u2019ll usually want to use an autoRun helper.","title":"CoAutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/#constructors","text":"CoAutoRunner [common] fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >)","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/#functions","text":"Name Summary dispose [common] open override fun dispose () Stops watching observables. run [common] suspend fun run (): T Calls observer and tracks its dependencies. triggerChange [common] open override fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/-co-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / CoAutoRunner / CoAutoRunner CoAutoRunner \u00b6 [common]\\ fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >) Parameters \u00b6 common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables.","title":" co auto runner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/-co-auto-runner/#coautorunner","text":"[common]\\ fun CoAutoRunner (launcher: CoroutineLauncher , onChange: CoAutoRunOnChangeCallback < T >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = launcher.loading, observer: CoAutoRunCallback < T >)","title":"CoAutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/-co-auto-runner/#parameters","text":"common launcher The CoroutineLauncher to use. onChange Gets called when the observables change. Your onChange handler has to manually call run at any point (e.g. asynchronously) to change the tracked observables. flowTransformer How changes should be executed/collected. Defaults to conflatedWorker . dispatcher The CoroutineDispatcher to use. Defaults to dispatchers.default . withLoading Tracks loading state for the (re-)computation. Defaults to CoroutineLauncher.loading . observer The callback which is used to track the observables.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/attached-disposables/","text":"// reactivestate-core / com.ensody.reactivestate / CoAutoRunner / attachedDisposables attachedDisposables \u00b6 [common]\\ open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"Attached disposables"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/attached-disposables/#attacheddisposables","text":"[common]\\ open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"attachedDisposables"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/run/","text":"// reactivestate-core / com.ensody.reactivestate / CoAutoRunner / run run \u00b6 [common]\\ suspend fun run (): T Calls observer and tracks its dependencies.","title":"Run"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-co-auto-runner/run/#run","text":"[common]\\ suspend fun run (): T Calls observer and tracks its dependencies.","title":"run"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineDispatcherConfig CoroutineDispatcherConfig \u00b6 [common]\\ interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers. Properties \u00b6 Name Summary default [common] abstract val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default. io [common] abstract val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO. main [common] abstract val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread). unconfined [common] abstract val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined. Inheritors \u00b6 Name DefaultCoroutineDispatcherConfig","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/#coroutinedispatcherconfig","text":"[common]\\ interface CoroutineDispatcherConfig Interface for a common set of CoroutineDispatchers.","title":"CoroutineDispatcherConfig"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/#properties","text":"Name Summary default [common] abstract val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default. io [common] abstract val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO. main [common] abstract val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread). unconfined [common] abstract val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/#inheritors","text":"Name DefaultCoroutineDispatcherConfig","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/default/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineDispatcherConfig / default default \u00b6 [common]\\ abstract val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default.","title":"Default"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/default/#default","text":"[common]\\ abstract val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default.","title":"default"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/io/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineDispatcherConfig / io io \u00b6 [common]\\ abstract val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO.","title":"Io"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/io/#io","text":"[common]\\ abstract val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO.","title":"io"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/main/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineDispatcherConfig / main main \u00b6 [common]\\ abstract val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"Main"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/main/#main","text":"[common]\\ abstract val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"main"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/unconfined/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineDispatcherConfig / unconfined unconfined \u00b6 [common]\\ abstract val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Unconfined"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-dispatcher-config/unconfined/#unconfined","text":"[common]\\ abstract val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"unconfined"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineLauncher CoroutineLauncher \u00b6 [common]\\ interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. You can track multiple different kinds of loading states by defining separate MutableValueFlow . See also \u00b6 common ReactiveState for a full implementation that you\u2019ll usually want to use. Functions \u00b6 Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors. Properties \u00b6 Name Summary launcherScope [common] abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int > The default loading tracker. Inheritors \u00b6 Name ReactiveState SimpleCoroutineLauncher Extensions \u00b6 Name Summary autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/#coroutinelauncher","text":"[common]\\ interface CoroutineLauncher Interface for launching coroutines with error handling and loading state tracking. You can track multiple different kinds of loading states by defining separate MutableValueFlow .","title":"CoroutineLauncher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/#see-also","text":"common ReactiveState for a full implementation that you\u2019ll usually want to use.","title":"See also"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/#functions","text":"Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/#properties","text":"Name Summary launcherScope [common] abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int > The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/#inheritors","text":"Name ReactiveState SimpleCoroutineLauncher","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/#extensions","text":"Name Summary autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/launch/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineLauncher / launch launch \u00b6 [common]\\ open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. Parameters \u00b6 common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect ). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Launch"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/launch/#launch","text":"[common]\\ open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state.","title":"launch"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/launch/#parameters","text":"common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect ). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/launcher-scope/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineLauncher / launcherScope launcherScope \u00b6 [common]\\ abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher.","title":"Launcher scope"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/launcher-scope/#launcherscope","text":"[common]\\ abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher.","title":"launcherScope"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/loading/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineLauncher / loading loading \u00b6 [common]\\ abstract val loading : MutableValueFlow < Int > The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"Loading"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/loading/#loading","text":"[common]\\ abstract val loading : MutableValueFlow < Int > The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"loading"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/on-error/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineLauncher / onError onError \u00b6 [common]\\ open fun onError (error: Throwable )","title":"On error"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/on-error/#onerror","text":"[common]\\ open fun onError (error: Throwable )","title":"onError"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/raw-launch/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineLauncher / rawLaunch rawLaunch \u00b6 [common]\\ open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. Parameters \u00b6 common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. block the coroutine code which will be invoked in the context of the provided scope.","title":"Raw launch"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/raw-launch/#rawlaunch","text":"[common]\\ open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking.","title":"rawLaunch"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/raw-launch/#parameters","text":"common context additional to CoroutineScope.coroutineContext context of the coroutine. start coroutine start option. The default value is CoroutineStart.DEFAULT. block the coroutine code which will be invoked in the context of the provided scope.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/track/","text":"// reactivestate-core / com.ensody.reactivestate / CoroutineLauncher / track track \u00b6 [common]\\ open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors. Mark long-running coroutines by setting withLoading to loading state. Parameters \u00b6 common withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect ). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Track"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/track/#track","text":"[common]\\ open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors. Mark long-running coroutines by setting withLoading to loading state.","title":"track"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-coroutine-launcher/track/#parameters","text":"common withLoading Tracks loading state for the (re-)computation. Defaults to loading . This should be null for long-running / never-terminating coroutines (e.g. flow.collect ). onError Optional custom error handler. block the coroutine code which will be invoked in the context of the provided scope.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/","text":"// reactivestate-core / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig DefaultCoroutineDispatcherConfig \u00b6 [common]\\ object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers. Properties \u00b6 Name Summary default [common] open override val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default. io [common] open override val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO. main [common] open override val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread). unconfined [common] open override val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/#defaultcoroutinedispatcherconfig","text":"[common]\\ object DefaultCoroutineDispatcherConfig : CoroutineDispatcherConfig The default CoroutineDispatcherConfig , mapping to Dispatchers.","title":"DefaultCoroutineDispatcherConfig"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/#properties","text":"Name Summary default [common] open override val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default. io [common] open override val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO. main [common] open override val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread). unconfined [common] open override val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/default/","text":"// reactivestate-core / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / default default \u00b6 [common]\\ open override val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default.","title":"Default"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/default/#default","text":"[common]\\ open override val default : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Default.","title":"default"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/io/","text":"// reactivestate-core / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / io io \u00b6 [common]\\ open override val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO.","title":"Io"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/io/#io","text":"[common]\\ open override val io : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.IO.","title":"io"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/main/","text":"// reactivestate-core / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / main main \u00b6 [common]\\ open override val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"Main"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/main/#main","text":"[common]\\ open override val main : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Main (i.e. confined to the main UI thread).","title":"main"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/unconfined/","text":"// reactivestate-core / com.ensody.reactivestate / DefaultCoroutineDispatcherConfig / unconfined unconfined \u00b6 [common]\\ open override val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"Unconfined"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-default-coroutine-dispatcher-config/unconfined/#unconfined","text":"[common]\\ open override val unconfined : CoroutineDispatcher A coroutine dispatcher that behaves like Dispatchers.Unconfined.","title":"unconfined"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-dependency-accessor/","text":"// reactivestate-core / com.ensody.reactivestate / DependencyAccessor DependencyAccessor \u00b6 [common]\\ @ Target (allowedTargets = [ AnnotationTarget.PROPERTY ]) annotation class DependencyAccessor Marks dependency injection system accessors, so direct access must be explicitly opted in.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-dependency-accessor/#dependencyaccessor","text":"[common]\\ @ Target (allowedTargets = [ AnnotationTarget.PROPERTY ]) annotation class DependencyAccessor Marks dependency injection system accessors, so direct access must be explicitly opted in.","title":"DependencyAccessor"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableGroup DisposableGroup \u00b6 [common]\\ interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. On dispose this destroys all Disposable and Job instances attached to it. Functions \u00b6 Name Summary add [common] abstract fun add (disposable: Disposable ) Add a Disposable to this group. [common] abstract fun add (job: Job) Add a Job to this group. dispose [common] abstract fun dispose () remove [common] abstract fun remove (disposable: Disposable ) Remove a Disposable from this group. [common] abstract fun remove (job: Job) Remove a Job from this group. Properties \u00b6 Name Summary size [common] abstract val size : Int Inheritors \u00b6 Name WhileUsedReferenceToken Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/#disposablegroup","text":"[common]\\ interface DisposableGroup : DisposableHandle A Disposable that can dispose multiple Disposable and Job instances at once. On dispose this destroys all Disposable and Job instances attached to it.","title":"DisposableGroup"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/#functions","text":"Name Summary add [common] abstract fun add (disposable: Disposable ) Add a Disposable to this group. [common] abstract fun add (job: Job) Add a Job to this group. dispose [common] abstract fun dispose () remove [common] abstract fun remove (disposable: Disposable ) Remove a Disposable from this group. [common] abstract fun remove (job: Job) Remove a Job from this group.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/#properties","text":"Name Summary size [common] abstract val size : Int","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/#inheritors","text":"Name WhileUsedReferenceToken","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/add/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableGroup / add add \u00b6 [common]\\ abstract fun add (disposable: Disposable ) Add a Disposable to this group. [common]\\ abstract fun add (job: Job) Add a Job to this group.","title":"Add"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/add/#add","text":"[common]\\ abstract fun add (disposable: Disposable ) Add a Disposable to this group. [common]\\ abstract fun add (job: Job) Add a Job to this group.","title":"add"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/remove/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableGroup / remove remove \u00b6 [common]\\ abstract fun remove (disposable: Disposable ) Remove a Disposable from this group. [common]\\ abstract fun remove (job: Job) Remove a Job from this group.","title":"Remove"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/remove/#remove","text":"[common]\\ abstract fun remove (disposable: Disposable ) Remove a Disposable from this group. [common]\\ abstract fun remove (job: Job) Remove a Job from this group.","title":"remove"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/size/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableGroup / size size \u00b6 [common]\\ abstract val size : Int","title":"Size"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-group/size/#size","text":"[common]\\ abstract val size : Int","title":"size"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableValue DisposableValue \u00b6 [common]\\ class DisposableValue < T >(val value: T , disposer: () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore. Constructors \u00b6 DisposableValue [common] fun < T > DisposableValue (value: T , disposer: () -> Unit ) Functions \u00b6 Name Summary dispose [common] open override fun dispose () Properties \u00b6 Name Summary value [common] val value : T Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/#disposablevalue","text":"[common]\\ class DisposableValue < T >(val value: T , disposer: () -> Unit ) : DisposableHandle A value that must be explicitly dispose d when it\u2019s not needed anymore.","title":"DisposableValue"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/#constructors","text":"DisposableValue [common] fun < T > DisposableValue (value: T , disposer: () -> Unit )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/#functions","text":"Name Summary dispose [common] open override fun dispose ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/#properties","text":"Name Summary value [common] val value : T","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/-disposable-value/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableValue / DisposableValue DisposableValue \u00b6 [common]\\ fun < T > DisposableValue (value: T , disposer: () -> Unit )","title":" disposable value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/-disposable-value/#disposablevalue","text":"[common]\\ fun < T > DisposableValue (value: T , disposer: () -> Unit )","title":"DisposableValue"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/dispose/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableValue / dispose dispose \u00b6 [common]\\ open override fun dispose ()","title":"Dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/dispose/#dispose","text":"[common]\\ open override fun dispose ()","title":"dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/value/","text":"// reactivestate-core / com.ensody.reactivestate / DisposableValue / value value \u00b6 [common]\\ val value : T","title":"Value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-disposable-value/value/#value","text":"[common]\\ val value : T","title":"value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-error-events/","text":"// reactivestate-core / com.ensody.reactivestate / ErrorEvents ErrorEvents \u00b6 [common]\\ interface ErrorEvents Events interface with a simple onError event (e.g. for use with EventNotifier ). Functions \u00b6 Name Summary onError [common] abstract fun onError (error: Throwable ) Triggers an error event.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-error-events/#errorevents","text":"[common]\\ interface ErrorEvents Events interface with a simple onError event (e.g. for use with EventNotifier ).","title":"ErrorEvents"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-error-events/#functions","text":"Name Summary onError [common] abstract fun onError (error: Throwable ) Triggers an error event.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-error-events/on-error/","text":"// reactivestate-core / com.ensody.reactivestate / ErrorEvents / onError onError \u00b6 [common]\\ abstract fun onError (error: Throwable ) Triggers an error event.","title":"On error"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-error-events/on-error/#onerror","text":"[common]\\ abstract fun onError (error: Throwable ) Triggers an error event.","title":"onError"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/","text":"// reactivestate-core / com.ensody.reactivestate / EventNotifier EventNotifier \u00b6 [common]\\ interface EventNotifier < T > : MutableFlow < T .() -> Unit > This is used to send events to an observer. All events are queued for later processing. The possible events are defined as method calls on an interface T . This allows for easy composition of multiple events. One of the most common events interfaces is ErrorEvents . See also \u00b6 common ReactiveState for more advanced usage of this pattern. Example: kotlin interface MyHandlerEvents : ErrorEvents, OtherEvents { fun onSomethingHappened() }<br>class MyHandler { val eventNotifier = EventNotifier<MyHandlerEvents>()<br> fun doSomething() { withErrorReporting(eventNotifier) { if (computeResult() 5) { eventNotifier { onSomethingHappened() } } else { eventNotifier { onOtherEvent() } } } } } Functions \u00b6 Name Summary collect [common] abstract suspend fun collect (collector: FlowCollector< T .() -> Unit >) emit [common] abstract suspend fun emit (value: T .() -> Unit ) invoke [common] abstract operator fun invoke (block: T .() -> Unit ) Adds a lambda function to the event stream. tryEmit [common] abstract fun tryEmit (value: T .() -> Unit ): Boolean Adds a value to this Flow if there\u2019s still capacity left. Extensions \u00b6 Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. handleEvents [common] suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/#eventnotifier","text":"[common]\\ interface EventNotifier < T > : MutableFlow < T .() -> Unit > This is used to send events to an observer. All events are queued for later processing. The possible events are defined as method calls on an interface T . This allows for easy composition of multiple events. One of the most common events interfaces is ErrorEvents .","title":"EventNotifier"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/#see-also","text":"common ReactiveState for more advanced usage of this pattern. Example: kotlin interface MyHandlerEvents : ErrorEvents, OtherEvents { fun onSomethingHappened() }<br>class MyHandler { val eventNotifier = EventNotifier<MyHandlerEvents>()<br> fun doSomething() { withErrorReporting(eventNotifier) { if (computeResult() 5) { eventNotifier { onSomethingHappened() } } else { eventNotifier { onOtherEvent() } } } } }","title":"See also"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/#functions","text":"Name Summary collect [common] abstract suspend fun collect (collector: FlowCollector< T .() -> Unit >) emit [common] abstract suspend fun emit (value: T .() -> Unit ) invoke [common] abstract operator fun invoke (block: T .() -> Unit ) Adds a lambda function to the event stream. tryEmit [common] abstract fun tryEmit (value: T .() -> Unit ): Boolean Adds a value to this Flow if there\u2019s still capacity left.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/#extensions","text":"Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. handleEvents [common] suspend fun < T : ErrorEvents > EventNotifier < T >. handleEvents (handler: T ) Consumes and handles EventNotifier \u2018s events on the given handler . latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/invoke/","text":"// reactivestate-core / com.ensody.reactivestate / EventNotifier / invoke invoke \u00b6 [common]\\ abstract operator fun invoke (block: T .() -> Unit ) Adds a lambda function to the event stream.","title":"Invoke"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-event-notifier/invoke/#invoke","text":"[common]\\ abstract operator fun invoke (block: T .() -> Unit ) Adds a lambda function to the event stream.","title":"invoke"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-experimental-reactive-state-api/","text":"// reactivestate-core / com.ensody.reactivestate / ExperimentalReactiveStateApi ExperimentalReactiveStateApi \u00b6 [common]\\ annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-experimental-reactive-state-api/#experimentalreactivestateapi","text":"[common]\\ annotation class ExperimentalReactiveStateApi This feature is not stable yet and can introduce breaking API changes in minor releases.","title":"ExperimentalReactiveStateApi"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/","text":"// reactivestate-core / com.ensody.reactivestate / InMemoryStateFlowStore InMemoryStateFlowStore \u00b6 [common]\\ class InMemoryStateFlowStore (val underlyingData: MutableMap < String , Any ?> = mutableMapOf()) : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects. Constructors \u00b6 InMemoryStateFlowStore [common] fun InMemoryStateFlowStore (underlyingData: MutableMap < String , Any ?> = mutableMapOf()) Functions \u00b6 Name Summary contains [common] open operator override fun contains (key: String ): Boolean getData [common] open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: (value: T ) -> Unit ?): MutableValueFlow < T > Properties \u00b6 Name Summary underlyingData [common] val underlyingData : MutableMap < String , Any ?> Optional underlying data which can be used to store and restore the whole state. Extensions \u00b6 Name Summary getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/#inmemorystateflowstore","text":"[common]\\ class InMemoryStateFlowStore (val underlyingData: MutableMap < String , Any ?> = mutableMapOf()) : StateFlowStore A StateFlowStore that can be used for unit tests or non-Android parts of multiplatform projects.","title":"InMemoryStateFlowStore"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/#constructors","text":"InMemoryStateFlowStore [common] fun InMemoryStateFlowStore (underlyingData: MutableMap < String , Any ?> = mutableMapOf())","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/#functions","text":"Name Summary contains [common] open operator override fun contains (key: String ): Boolean getData [common] open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: (value: T ) -> Unit ?): MutableValueFlow < T >","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/#properties","text":"Name Summary underlyingData [common] val underlyingData : MutableMap < String , Any ?> Optional underlying data which can be used to store and restore the whole state.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/#extensions","text":"Name Summary getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/-in-memory-state-flow-store/","text":"// reactivestate-core / com.ensody.reactivestate / InMemoryStateFlowStore / InMemoryStateFlowStore InMemoryStateFlowStore \u00b6 [common]\\ fun InMemoryStateFlowStore (underlyingData: MutableMap < String , Any ?> = mutableMapOf())","title":" in memory state flow store"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/-in-memory-state-flow-store/#inmemorystateflowstore","text":"[common]\\ fun InMemoryStateFlowStore (underlyingData: MutableMap < String , Any ?> = mutableMapOf())","title":"InMemoryStateFlowStore"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/contains/","text":"// reactivestate-core / com.ensody.reactivestate / InMemoryStateFlowStore / contains contains \u00b6 [common]\\ open operator override fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/contains/#contains","text":"[common]\\ open operator override fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/get-data/","text":"// reactivestate-core / com.ensody.reactivestate / InMemoryStateFlowStore / getData getData \u00b6 [common]\\ open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: (value: T ) -> Unit ?): MutableValueFlow < T >","title":"Get data"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/get-data/#getdata","text":"[common]\\ open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > fun < T > getData (key: String , default: T , setter: (value: T ) -> Unit ?): MutableValueFlow < T >","title":"getData"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/underlying-data/","text":"// reactivestate-core / com.ensody.reactivestate / InMemoryStateFlowStore / underlyingData underlyingData \u00b6 [common]\\ val underlyingData : MutableMap < String , Any ?> Optional underlying data which can be used to store and restore the whole state.","title":"Underlying data"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-in-memory-state-flow-store/underlying-data/#underlyingdata","text":"[common]\\ val underlyingData : MutableMap < String , Any ?> Optional underlying data which can be used to store and restore the whole state.","title":"underlyingData"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / InternalBaseAutoRunner InternalBaseAutoRunner \u00b6 [common]\\ abstract class InternalBaseAutoRunner (val launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer ) : BaseAutoRunner Constructors \u00b6 InternalBaseAutoRunner [common] fun InternalBaseAutoRunner (launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer ) Functions \u00b6 Name Summary dispose [common] open override fun dispose () Stops watching observables. triggerChange [common] open override fun triggerChange () Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher Inheritors \u00b6 Name AutoRunner CoAutoRunner Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/#internalbaseautorunner","text":"[common]\\ abstract class InternalBaseAutoRunner (val launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer ) : BaseAutoRunner","title":"InternalBaseAutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/#constructors","text":"InternalBaseAutoRunner [common] fun InternalBaseAutoRunner (launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/#functions","text":"Name Summary dispose [common] open override fun dispose () Stops watching observables. triggerChange [common] open override fun triggerChange ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed. launcher [common] override val launcher : CoroutineLauncher","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/#inheritors","text":"Name AutoRunner CoAutoRunner","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/-internal-base-auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / InternalBaseAutoRunner / InternalBaseAutoRunner InternalBaseAutoRunner \u00b6 [common]\\ fun InternalBaseAutoRunner (launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer )","title":" internal base auto runner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/-internal-base-auto-runner/#internalbaseautorunner","text":"[common]\\ fun InternalBaseAutoRunner (launcher: CoroutineLauncher , flowTransformer: AutoRunFlowTransformer )","title":"InternalBaseAutoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/attached-disposables/","text":"// reactivestate-core / com.ensody.reactivestate / InternalBaseAutoRunner / attachedDisposables attachedDisposables \u00b6 [common]\\ open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"Attached disposables"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/attached-disposables/#attacheddisposables","text":"[common]\\ open override val attachedDisposables : DisposableGroup The attached disposables which should be auto-disposed when this object is disposed.","title":"attachedDisposables"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/dispose/","text":"// reactivestate-core / com.ensody.reactivestate / InternalBaseAutoRunner / dispose dispose \u00b6 [common]\\ open override fun dispose () Stops watching observables.","title":"Dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/dispose/#dispose","text":"[common]\\ open override fun dispose () Stops watching observables.","title":"dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/launcher/","text":"// reactivestate-core / com.ensody.reactivestate / InternalBaseAutoRunner / launcher launcher \u00b6 [common]\\ override val launcher : CoroutineLauncher","title":"Launcher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/launcher/#launcher","text":"[common]\\ override val launcher : CoroutineLauncher","title":"launcher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/trigger-change/","text":"// reactivestate-core / com.ensody.reactivestate / InternalBaseAutoRunner / triggerChange triggerChange \u00b6 [common]\\ open override fun triggerChange ()","title":"Trigger change"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-internal-base-auto-runner/trigger-change/#triggerchange","text":"[common]\\ open override fun triggerChange ()","title":"triggerChange"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/","text":"// reactivestate-core / com.ensody.reactivestate / JobDisposable JobDisposable \u00b6 [common]\\ class JobDisposable (job: Job) : DisposableHandle A Disposable wrapping a Job. Constructors \u00b6 JobDisposable [common] fun JobDisposable (job: Job) Functions \u00b6 Name Summary dispose [common] open override fun dispose () Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/#jobdisposable","text":"[common]\\ class JobDisposable (job: Job) : DisposableHandle A Disposable wrapping a Job.","title":"JobDisposable"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/#constructors","text":"JobDisposable [common] fun JobDisposable (job: Job)","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/#functions","text":"Name Summary dispose [common] open override fun dispose ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/-job-disposable/","text":"// reactivestate-core / com.ensody.reactivestate / JobDisposable / JobDisposable JobDisposable \u00b6 [common]\\ fun JobDisposable (job: Job)","title":" job disposable"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/-job-disposable/#jobdisposable","text":"[common]\\ fun JobDisposable (job: Job)","title":"JobDisposable"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/dispose/","text":"// reactivestate-core / com.ensody.reactivestate / JobDisposable / dispose dispose \u00b6 [common]\\ open override fun dispose ()","title":"Dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-job-disposable/dispose/#dispose","text":"[common]\\ open override fun dispose ()","title":"dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/","text":"// reactivestate-core / com.ensody.reactivestate / MutableFlow MutableFlow \u00b6 [common]\\ interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel). Functions \u00b6 Name Summary collect [common] abstract suspend fun collect (collector: FlowCollector< T >) emit [common] abstract suspend fun emit (value: T ) tryEmit [common] abstract fun tryEmit (value: T ): Boolean Adds a value to this Flow if there\u2019s still capacity left. Inheritors \u00b6 Name EventNotifier Extensions \u00b6 Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/#mutableflow","text":"[common]\\ interface MutableFlow < T > : Flow< T > , FlowCollector< T > A Flow where you can emit/ tryEmit values into (backed by a Channel).","title":"MutableFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/#functions","text":"Name Summary collect [common] abstract suspend fun collect (collector: FlowCollector< T >) emit [common] abstract suspend fun emit (value: T ) tryEmit [common] abstract fun tryEmit (value: T ): Boolean Adds a value to this Flow if there\u2019s still capacity left.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/#inheritors","text":"Name EventNotifier","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/#extensions","text":"Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/try-emit/","text":"// reactivestate-core / com.ensody.reactivestate / MutableFlow / tryEmit tryEmit \u00b6 [common]\\ abstract fun tryEmit (value: T ): Boolean Adds a value to this Flow if there\u2019s still capacity left.","title":"Try emit"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-flow/try-emit/#tryemit","text":"[common]\\ abstract fun tryEmit (value: T ): Boolean Adds a value to this Flow if there\u2019s still capacity left.","title":"tryEmit"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/","text":"// reactivestate-core / com.ensody.reactivestate / MutableValueFlow MutableValueFlow \u00b6 [common]\\ interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. Assigning to .value still has distinctUntilChanged behavior, but emit / tryEmit and update always trigger a change event. Example of mutating the value in-place: flow . update { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } Why is this needed? In Kotlin, working with nested immutable values (e.g. nested data class with val) is very unwieldy because you have to manually copy each element and its children: flow . value = flow . value . let { it . copy ( subvalue1 = it . subvalue1 . copy ( deepsubvalue = it . subvalue1 . deepsubvalue . copy ( somevalue = it . subvalue1 . deepsubvalue . somevalue + 3 ) ), subvalue2 = it . subvalue2 . copy ( state = SomeState . IN_PROGRESS ), isLoading = true , ) } In many cases the UI state is even held in mutable data classes (with var), but doing the following would be unsafe with MutableStateFlow because the value is considered unchanged, so this code won\u2019t trigger a UI update: flow . value = flow . value . also { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } Kotlin just isn\u2019t a pure functional language with built-in lens support and we have to deal with mutable values, so we should prevent overly complicated code with nested copy() and stupid mistakes like missing UI updates. That\u2019s why MutableValueFlow tries to make working with mutable values easy and safe. Functions \u00b6 Name Summary collect [common] abstract suspend override fun collect (collector: FlowCollector< T >): Nothing compareAndSet [common] abstract fun compareAndSet (expect: T , update: T ): Boolean emit [common] abstract suspend override fun emit (value: T ) replaceLocked [common] abstract fun replaceLocked (block: T .() -> T ): T Replaces the value with block \u2018s return value. This is safe under concurrency. resetReplayCache [common] abstract fun resetReplayCache () tryEmit [common] abstract fun tryEmit (value: T ): Boolean update [common] abstract fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg. updateThis [common] open fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this. Properties \u00b6 Name Summary replayCache [common] abstract val replayCache : List < T > subscriptionCount [common] abstract val subscriptionCount : StateFlow< Int > value [common] abstract val value : T Extensions \u00b6 Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. afterUpdate [common] fun < T > MutableStateFlow< T >. afterUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter after doing the actual value update. beforeUpdate [common] fun < T > MutableStateFlow< T >. beforeUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter before doing the actual value update. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. decrement [common] fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . increment [common] fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom [common] suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest. replace [common] fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. withSetter [common] fun < T > MutableStateFlow< T >. withSetter (setter: MutableStateFlow< T >.( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter instead of doing the actual value update.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/#mutablevalueflow","text":"[common]\\ interface MutableValueFlow < T > : ValueFlow < T > , MutableStateFlow< T > A version of MutableStateFlow that provides better support for mutable values via the update operation. Assigning to .value still has distinctUntilChanged behavior, but emit / tryEmit and update always trigger a change event. Example of mutating the value in-place: flow . update { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } Why is this needed? In Kotlin, working with nested immutable values (e.g. nested data class with val) is very unwieldy because you have to manually copy each element and its children: flow . value = flow . value . let { it . copy ( subvalue1 = it . subvalue1 . copy ( deepsubvalue = it . subvalue1 . deepsubvalue . copy ( somevalue = it . subvalue1 . deepsubvalue . somevalue + 3 ) ), subvalue2 = it . subvalue2 . copy ( state = SomeState . IN_PROGRESS ), isLoading = true , ) } In many cases the UI state is even held in mutable data classes (with var), but doing the following would be unsafe with MutableStateFlow because the value is considered unchanged, so this code won\u2019t trigger a UI update: flow . value = flow . value . also { it . subvalue1 . deepsubvalue . somevalue += 3 it . subvalue2 . state = SomeState . IN_PROGRESS it . isLoading = true } Kotlin just isn\u2019t a pure functional language with built-in lens support and we have to deal with mutable values, so we should prevent overly complicated code with nested copy() and stupid mistakes like missing UI updates. That\u2019s why MutableValueFlow tries to make working with mutable values easy and safe.","title":"MutableValueFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/#functions","text":"Name Summary collect [common] abstract suspend override fun collect (collector: FlowCollector< T >): Nothing compareAndSet [common] abstract fun compareAndSet (expect: T , update: T ): Boolean emit [common] abstract suspend override fun emit (value: T ) replaceLocked [common] abstract fun replaceLocked (block: T .() -> T ): T Replaces the value with block \u2018s return value. This is safe under concurrency. resetReplayCache [common] abstract fun resetReplayCache () tryEmit [common] abstract fun tryEmit (value: T ): Boolean update [common] abstract fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg. updateThis [common] open fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/#properties","text":"Name Summary replayCache [common] abstract val replayCache : List < T > subscriptionCount [common] abstract val subscriptionCount : StateFlow< Int > value [common] abstract val value : T","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/#extensions","text":"Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. afterUpdate [common] fun < T > MutableStateFlow< T >. afterUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter after doing the actual value update. beforeUpdate [common] fun < T > MutableStateFlow< T >. beforeUpdate (setter: ( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter before doing the actual value update. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. decrement [common] fun MutableValueFlow < Int >. decrement (amount: Int = 1): Int Atomically decrement this MutableValueFlow by amount . increment [common] fun MutableValueFlow < Int >. increment (amount: Int = 1): Int Atomically increment this MutableValueFlow by amount . incrementFrom [common] suspend fun MutableValueFlow < Int >. incrementFrom (flow: StateFlow< Int >) Keeps this incremented increment by the latest value in the given flow . latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest. replace [common] fun < T > MutableStateFlow< T >. replace (block: T .() -> T ): T Replaces the MutableStateFlow.value with block \u2018s return value. withSetter [common] fun < T > MutableStateFlow< T >. withSetter (setter: MutableStateFlow< T >.( T ) -> Unit ): MutableStateFlow< T > Returns a new MutableStateFlow that calls setter instead of doing the actual value update.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/replace-locked/","text":"// reactivestate-core / com.ensody.reactivestate / MutableValueFlow / replaceLocked replaceLocked \u00b6 [common]\\ abstract fun replaceLocked (block: T .() -> T ): T Replaces the value with block \u2018s return value. This is safe under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo ( val num : Int ) val stateFlow = MutableStateFlow ( Foo ( 3 )) stateFlow . replace { copy ( num = 5 ) } Return \u00b6 The previous value before replacing. See also \u00b6 common increment and decrement for functions optimized for Int operations.","title":"Replace locked"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/replace-locked/#replacelocked","text":"[common]\\ abstract fun replaceLocked (block: T .() -> T ): T Replaces the value with block \u2018s return value. This is safe under concurrency. This is a simple helper for the common case where you want to copy() a data class: data class Foo ( val num : Int ) val stateFlow = MutableStateFlow ( Foo ( 3 )) stateFlow . replace { copy ( num = 5 ) }","title":"replaceLocked"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/replace-locked/#return","text":"The previous value before replacing.","title":"Return"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/replace-locked/#see-also","text":"common increment and decrement for functions optimized for Int operations.","title":"See also"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/update-this/","text":"// reactivestate-core / com.ensody.reactivestate / MutableValueFlow / updateThis updateThis \u00b6 [common]\\ open fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Update this"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/update-this/#updatethis","text":"[common]\\ open fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"updateThis"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/update/","text":"// reactivestate-core / com.ensody.reactivestate / MutableValueFlow / update update \u00b6 [common]\\ abstract fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"Update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-mutable-value-flow/update/#update","text":"[common]\\ abstract fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/","text":"// reactivestate-core / com.ensody.reactivestate / NamespacedStateFlowStore NamespacedStateFlowStore \u00b6 [common]\\ class NamespacedStateFlowStore (store: StateFlowStore , namespace: String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. This is useful for preventing name clashes when passing StateFlowStore s to sub-components. Constructors \u00b6 NamespacedStateFlowStore [common] fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String ) Functions \u00b6 Name Summary contains [common] open operator override fun contains (key: String ): Boolean getData [common] open override fun < T > getData (key: String , default: T ): MutableValueFlow < T > Extensions \u00b6 Name Summary getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/#namespacedstateflowstore","text":"[common]\\ class NamespacedStateFlowStore (store: StateFlowStore , namespace: String ) : StateFlowStore A wrapper StateFlowStore that prefixes every key with a namespace. This is useful for preventing name clashes when passing StateFlowStore s to sub-components.","title":"NamespacedStateFlowStore"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/#constructors","text":"NamespacedStateFlowStore [common] fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/#functions","text":"Name Summary contains [common] open operator override fun contains (key: String ): Boolean getData [common] open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/#extensions","text":"Name Summary getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/-namespaced-state-flow-store/","text":"// reactivestate-core / com.ensody.reactivestate / NamespacedStateFlowStore / NamespacedStateFlowStore NamespacedStateFlowStore \u00b6 [common]\\ fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String )","title":" namespaced state flow store"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/-namespaced-state-flow-store/#namespacedstateflowstore","text":"[common]\\ fun NamespacedStateFlowStore (store: StateFlowStore , namespace: String )","title":"NamespacedStateFlowStore"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/contains/","text":"// reactivestate-core / com.ensody.reactivestate / NamespacedStateFlowStore / contains contains \u00b6 [common]\\ open operator override fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/contains/#contains","text":"[common]\\ open operator override fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/get-data/","text":"// reactivestate-core / com.ensody.reactivestate / NamespacedStateFlowStore / getData getData \u00b6 [common]\\ open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Get data"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-namespaced-state-flow-store/get-data/#getdata","text":"[common]\\ open override fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"getData"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/","text":"// reactivestate-core / com.ensody.reactivestate / OnDispose OnDispose \u00b6 [common]\\ class OnDispose (function: () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose() . Example: val disposable = OnDispose { println ( \"disposing myself\" ) } disposable . dispose () // => \"disposing myself\" Constructors \u00b6 OnDispose [common] fun OnDispose (function: () -> Unit ) Functions \u00b6 Name Summary dispose [common] open override fun dispose () Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/#ondispose","text":"[common]\\ class OnDispose (function: () -> Unit ) : DisposableHandle A Disposable executing the given function on dispose() . Example: val disposable = OnDispose { println ( \"disposing myself\" ) } disposable . dispose () // => \"disposing myself\"","title":"OnDispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/#constructors","text":"OnDispose [common] fun OnDispose (function: () -> Unit )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/#functions","text":"Name Summary dispose [common] open override fun dispose ()","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/-on-dispose/","text":"// reactivestate-core / com.ensody.reactivestate / OnDispose / OnDispose OnDispose \u00b6 [common]\\ fun OnDispose (function: () -> Unit )","title":" on dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/-on-dispose/#ondispose","text":"[common]\\ fun OnDispose (function: () -> Unit )","title":"OnDispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/dispose/","text":"// reactivestate-core / com.ensody.reactivestate / OnDispose / dispose dispose \u00b6 [common]\\ open override fun dispose ()","title":"Dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-dispose/dispose/#dispose","text":"[common]\\ open override fun dispose ()","title":"dispose"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-reactive-state-attached/","text":"// reactivestate-core / com.ensody.reactivestate / OnReactiveStateAttached OnReactiveStateAttached \u00b6 [common]\\ interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. This can be useful e.g. to map ReactiveState.loading to a setLoading(isLoading: Boolean) method in every UI screen (e.g. on Android you could have a BaseFragment implementing this interface). Functions \u00b6 Name Summary onReactiveStateAttached [common] abstract fun onReactiveStateAttached (reactiveState: ReactiveState <out ErrorEvents >)","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-reactive-state-attached/#onreactivestateattached","text":"[common]\\ interface OnReactiveStateAttached Implement this interface to get notified of every ReactiveState added to your object. This can be useful e.g. to map ReactiveState.loading to a setLoading(isLoading: Boolean) method in every UI screen (e.g. on Android you could have a BaseFragment implementing this interface).","title":"OnReactiveStateAttached"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-reactive-state-attached/#functions","text":"Name Summary onReactiveStateAttached [common] abstract fun onReactiveStateAttached (reactiveState: ReactiveState <out ErrorEvents >)","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-reactive-state-attached/on-reactive-state-attached/","text":"// reactivestate-core / com.ensody.reactivestate / OnReactiveStateAttached / onReactiveStateAttached onReactiveStateAttached \u00b6 [common]\\ abstract fun onReactiveStateAttached (reactiveState: ReactiveState <out ErrorEvents >)","title":"On reactive state attached"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-on-reactive-state-attached/on-reactive-state-attached/#onreactivestateattached","text":"[common]\\ abstract fun onReactiveStateAttached (reactiveState: ReactiveState <out ErrorEvents >)","title":"onReactiveStateAttached"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/","text":"// reactivestate-core / com.ensody.reactivestate / ReactiveState ReactiveState \u00b6 [common]\\ interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling. See also \u00b6 common BaseReactiveState for a ready-made base class (or delegate). Functions \u00b6 Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors. Properties \u00b6 Name Summary eventNotifier [common] abstract val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int > The default loading tracker. Inheritors \u00b6 Name BaseReactiveState Extensions \u00b6 Name Summary attachTo [common] fun ReactiveState <out ErrorEvents >. attachTo (owner: Any ) autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/#reactivestate","text":"[common]\\ interface ReactiveState < E : ErrorEvents > : CoroutineLauncher An interface for ViewModels and any other objects that can trigger one-time events/actions and handle errors. Make sure you always launch coroutines via launch (instead of the scope) to get automatic error handling.","title":"ReactiveState"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/#see-also","text":"common BaseReactiveState for a ready-made base class (or delegate).","title":"See also"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/#functions","text":"Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/#properties","text":"Name Summary eventNotifier [common] abstract val eventNotifier : EventNotifier < E > launcherScope [common] abstract val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] abstract val loading : MutableValueFlow < Int > The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/#inheritors","text":"Name BaseReactiveState","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/#extensions","text":"Name Summary attachTo [common] fun ReactiveState <out ErrorEvents >. attachTo (owner: Any ) autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/event-notifier/","text":"// reactivestate-core / com.ensody.reactivestate / ReactiveState / eventNotifier eventNotifier \u00b6 [common]\\ abstract val eventNotifier : EventNotifier < E >","title":"Event notifier"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-reactive-state/event-notifier/#eventnotifier","text":"[common]\\ abstract val eventNotifier : EventNotifier < E >","title":"eventNotifier"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/","text":"// reactivestate-core / com.ensody.reactivestate / Resolver Resolver \u00b6 [common]\\ class Resolver (val autoRunner: BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner . Constructors \u00b6 Resolver [common] fun Resolver (autoRunner: BaseAutoRunner ) Functions \u00b6 Name Summary track [common] fun < S : Any , T : AutoRunnerObservable < V >, V > track (underlyingObservable: S , getObservable: () -> T ): T Tracks an arbitrary observable. Properties \u00b6 Name Summary autoRunner [common] val autoRunner : BaseAutoRunner Extensions \u00b6 Name Summary get [common] fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope ). [common] fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/#resolver","text":"[common]\\ class Resolver (val autoRunner: BaseAutoRunner ) Tracks observables for AutoRunner and CoAutoRunner .","title":"Resolver"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/#constructors","text":"Resolver [common] fun Resolver (autoRunner: BaseAutoRunner )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/#functions","text":"Name Summary track [common] fun < S : Any , T : AutoRunnerObservable < V >, V > track (underlyingObservable: S , getObservable: () -> T ): T Tracks an arbitrary observable.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/#properties","text":"Name Summary autoRunner [common] val autoRunner : BaseAutoRunner","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/#extensions","text":"Name Summary get [common] fun < T > Resolver . get (data: StateFlow< T >): T Returns StateFlow.value and tracks the observable (on the MainScope ). [common] fun < T > Resolver . get (data: WhileUsed < T >): T Returns WhileUsed \u2018s value and keeps it alive as long as it\u2019s still used.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/-resolver/","text":"// reactivestate-core / com.ensody.reactivestate / Resolver / Resolver Resolver \u00b6 [common]\\ fun Resolver (autoRunner: BaseAutoRunner )","title":" resolver"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/-resolver/#resolver","text":"[common]\\ fun Resolver (autoRunner: BaseAutoRunner )","title":"Resolver"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/auto-runner/","text":"// reactivestate-core / com.ensody.reactivestate / Resolver / autoRunner autoRunner \u00b6 [common]\\ val autoRunner : BaseAutoRunner","title":"Auto runner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/auto-runner/#autorunner","text":"[common]\\ val autoRunner : BaseAutoRunner","title":"autoRunner"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/track/","text":"// reactivestate-core / com.ensody.reactivestate / Resolver / track track \u00b6 [common]\\ fun < S : Any , T : AutoRunnerObservable < V >, V > track (underlyingObservable: S , getObservable: () -> T ): T Tracks an arbitrary observable. This creates a new AutoRunnerObservable if one doesn\u2019t already exist for the underlyingObservable . Otherwise it reuses the existing AutoRunnerObservable . Return \u00b6 The instantiated AutoRunnerObservable of type T . Parameters \u00b6 common underlyingObservable The raw, underlying observable (e.g. Android\u2019s LiveData ). getObservable Used to create an AutoRunnerObservable wrapper around underlyingObservable .","title":"Track"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/track/#track","text":"[common]\\ fun < S : Any , T : AutoRunnerObservable < V >, V > track (underlyingObservable: S , getObservable: () -> T ): T Tracks an arbitrary observable. This creates a new AutoRunnerObservable if one doesn\u2019t already exist for the underlyingObservable . Otherwise it reuses the existing AutoRunnerObservable .","title":"track"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/track/#return","text":"The instantiated AutoRunnerObservable of type T .","title":"Return"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-resolver/track/#parameters","text":"common underlyingObservable The raw, underlying observable (e.g. Android\u2019s LiveData ). getObservable Used to create an AutoRunnerObservable wrapper around underlyingObservable .","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-serializable/","text":"// reactivestate-core / com.ensody.reactivestate / Serializable Serializable \u00b6 [common]\\ expect interface Serializable Maps to java.io.Serializable on JVM. [nonJvm]\\ actual interface Serializable [jvmCommon]\\ actual typealias Serializable = <Error class: unknown class> Inheritors \u00b6 Name Wrapped","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-serializable/#serializable","text":"[common]\\ expect interface Serializable Maps to java.io.Serializable on JVM. [nonJvm]\\ actual interface Serializable [jvmCommon]\\ actual typealias Serializable = <Error class: unknown class>","title":"Serializable"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-serializable/#inheritors","text":"Name Wrapped","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/","text":"// reactivestate-core / com.ensody.reactivestate / SimpleCoroutineLauncher SimpleCoroutineLauncher \u00b6 [common]\\ open class SimpleCoroutineLauncher (val launcherScope: CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. Usually you\u2019ll want to use a ReactiveState which also does error handling. Constructors \u00b6 SimpleCoroutineLauncher [common] fun SimpleCoroutineLauncher (launcherScope: CoroutineScope) Functions \u00b6 Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors. Properties \u00b6 Name Summary launcherScope [common] override val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] override val loading : MutableValueFlow < Int > The default loading tracker. Inheritors \u00b6 Name BaseReactiveState Extensions \u00b6 Name Summary autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/#simplecoroutinelauncher","text":"[common]\\ open class SimpleCoroutineLauncher (val launcherScope: CoroutineScope) : CoroutineLauncher Simple default implementation of a CoroutineLauncher which uses a given CoroutineScope. Usually you\u2019ll want to use a ReactiveState which also does error handling.","title":"SimpleCoroutineLauncher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/#constructors","text":"SimpleCoroutineLauncher [common] fun SimpleCoroutineLauncher (launcherScope: CoroutineScope)","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/#functions","text":"Name Summary launch [common] open fun launch (context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine. Mark long-running coroutines by setting withLoading to loading state. onError [common] open fun onError (error: Throwable ) rawLaunch [common] open fun rawLaunch (context: CoroutineContext , start: CoroutineStart, block: suspend CoroutineScope.() -> Unit ): Job Launches a coroutine without any error handling or loading state tracking. track [common] open suspend fun track (withLoading: MutableValueFlow < Int >? = loading, onError: suspend ( Throwable ) -> Unit ? = null, block: suspend () -> Unit ) Tracks a suspension block \u2018s loading state and errors.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/#properties","text":"Name Summary launcherScope [common] override val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher. loading [common] override val loading : MutableValueFlow < Int > The default loading tracker.","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/#inheritors","text":"Name BaseReactiveState","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/#extensions","text":"Name Summary autoRun [common] fun CoroutineLauncher . autoRun (onChange: AutoRunOnChangeCallback < Unit >? = null, observer: AutoRunCallback < Unit >): AutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). coAutoRun [common] fun CoroutineLauncher . coAutoRun (onChange: CoAutoRunOnChangeCallback < Unit >? = null, flowTransformer: AutoRunFlowTransformer = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < Unit >): CoAutoRunner < Unit > Watches observables for changes. Often useful to keep things in sync (e.g. CoroutineLauncher -> UI). derived [common] fun < T > CoroutineLauncher . derived (observer: AutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via an autoRun block. [common] fun < T > CoroutineLauncher . derived (initial: T , started: SharingStarted = SharingStarted.Eagerly, flowTransformer: DerivedFlowTransformer < T > = { conflatedWorker(transform = it) }, dispatcher: CoroutineDispatcher = dispatchers.default, withLoading: MutableValueFlow < Int >? = loading, observer: CoAutoRunCallback < T >): StateFlow< T > Creates a StateFlow that computes its value based on other StateFlows via a suspendable coAutoRun block. invokeOnCompletion [common] fun CoroutineLauncher . invokeOnCompletion (handler: CompletionHandler): Disposable Helper for adding a completion handler to a CoroutineLauncher .","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/-simple-coroutine-launcher/","text":"// reactivestate-core / com.ensody.reactivestate / SimpleCoroutineLauncher / SimpleCoroutineLauncher SimpleCoroutineLauncher \u00b6 [common]\\ fun SimpleCoroutineLauncher (launcherScope: CoroutineScope)","title":" simple coroutine launcher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/-simple-coroutine-launcher/#simplecoroutinelauncher","text":"[common]\\ fun SimpleCoroutineLauncher (launcherScope: CoroutineScope)","title":"SimpleCoroutineLauncher"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/launcher-scope/","text":"// reactivestate-core / com.ensody.reactivestate / SimpleCoroutineLauncher / launcherScope launcherScope \u00b6 [common]\\ override val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher.","title":"Launcher scope"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/launcher-scope/#launcherscope","text":"[common]\\ override val launcherScope : CoroutineScope The underlying CoroutineScope of this launcher.","title":"launcherScope"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/loading/","text":"// reactivestate-core / com.ensody.reactivestate / SimpleCoroutineLauncher / loading loading \u00b6 [common]\\ override val loading : MutableValueFlow < Int > The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"Loading"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-simple-coroutine-launcher/loading/#loading","text":"[common]\\ override val loading : MutableValueFlow < Int > The default loading tracker. Use increment / decrement to safely update the loading counter.","title":"loading"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/","text":"// reactivestate-core / com.ensody.reactivestate / StateFlowStore StateFlowStore \u00b6 [common]\\ interface StateFlowStore Base interface for a temporary observable key-value store. This is useful for multiplatform projects and also for abstracting away SavedStateHandle , e.g. so you can write tests without Robolectric. Functions \u00b6 Name Summary contains [common] abstract operator fun contains (key: String ): Boolean getData [common] abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T > Inheritors \u00b6 Name InMemoryStateFlowStore NamespacedStateFlowStore Extensions \u00b6 Name Summary getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/#stateflowstore","text":"[common]\\ interface StateFlowStore Base interface for a temporary observable key-value store. This is useful for multiplatform projects and also for abstracting away SavedStateHandle , e.g. so you can write tests without Robolectric.","title":"StateFlowStore"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/#functions","text":"Name Summary contains [common] abstract operator fun contains (key: String ): Boolean getData [common] abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/#inheritors","text":"Name InMemoryStateFlowStore NamespacedStateFlowStore","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/#extensions","text":"Name Summary getData [common] fun < T > StateFlowStore . getData (default: T ): ReadOnlyProperty < Any ?, MutableValueFlow < T >> For use with by delegation. Returns the StateFlowStore entry for the key that equals the property name.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/contains/","text":"// reactivestate-core / com.ensody.reactivestate / StateFlowStore / contains contains \u00b6 [common]\\ abstract operator fun contains (key: String ): Boolean","title":"Contains"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/contains/#contains","text":"[common]\\ abstract operator fun contains (key: String ): Boolean","title":"contains"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/get-data/","text":"// reactivestate-core / com.ensody.reactivestate / StateFlowStore / getData getData \u00b6 [common]\\ abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"Get data"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-state-flow-store/get-data/#getdata","text":"[common]\\ abstract fun < T > getData (key: String , default: T ): MutableValueFlow < T >","title":"getData"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/","text":"// reactivestate-core / com.ensody.reactivestate / SuspendMutableValueFlow SuspendMutableValueFlow \u00b6 [common]\\ @ ExperimentalReactiveStateApi interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value. This is useful e.g. for values backed by some storage/backend system. See also \u00b6 common BaseSuspendMutableValueFlow which can be a useful base class for your custom implementation. Functions \u00b6 Name Summary collect [common] abstract suspend override fun collect (collector: FlowCollector< T >): Nothing replace [common] abstract suspend fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set [common] abstract suspend fun set (value: T , force: Boolean = false) Assigns a new value . update [common] abstract suspend fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg. updateThis [common] abstract suspend fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this. Properties \u00b6 Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T Inheritors \u00b6 Name BaseSuspendMutableValueFlow Extensions \u00b6 Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/#suspendmutablevalueflow","text":"[common]\\ @ ExperimentalReactiveStateApi interface SuspendMutableValueFlow < T > : ValueFlow < T > A StateFlow that can be mutated only via suspend functions - in contrast to assigning the value. This is useful e.g. for values backed by some storage/backend system.","title":"SuspendMutableValueFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/#see-also","text":"common BaseSuspendMutableValueFlow which can be a useful base class for your custom implementation.","title":"See also"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/#functions","text":"Name Summary collect [common] abstract suspend override fun collect (collector: FlowCollector< T >): Nothing replace [common] abstract suspend fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value. set [common] abstract suspend fun set (value: T , force: Boolean = false) Assigns a new value . update [common] abstract suspend fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg. updateThis [common] abstract suspend fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/#properties","text":"Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/#inheritors","text":"Name BaseSuspendMutableValueFlow","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/#extensions","text":"Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/replace/","text":"// reactivestate-core / com.ensody.reactivestate / SuspendMutableValueFlow / replace replace \u00b6 [common]\\ abstract suspend fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value.","title":"Replace"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/replace/#replace","text":"[common]\\ abstract suspend fun replace (block: T .() -> T ) Replaces the value with block \u2018s return value.","title":"replace"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/set/","text":"// reactivestate-core / com.ensody.reactivestate / SuspendMutableValueFlow / set set \u00b6 [common]\\ abstract suspend fun set (value: T , force: Boolean = false) Assigns a new value . Parameters \u00b6 common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false , behaving like MutableStateFlow.","title":"Set"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/set/#set","text":"[common]\\ abstract suspend fun set (value: T , force: Boolean = false) Assigns a new value .","title":"set"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/set/#parameters","text":"common value The new value to be assigned. force Whether to assign even if value is unchanged. Defaults to false , behaving like MutableStateFlow.","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/update-this/","text":"// reactivestate-core / com.ensody.reactivestate / SuspendMutableValueFlow / updateThis updateThis \u00b6 [common]\\ abstract suspend fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"Update this"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/update-this/#updatethis","text":"[common]\\ abstract suspend fun updateThis (block: T .() -> Unit ) Mutates value in-place and notifies listeners. The current value is passed via this.","title":"updateThis"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/update/","text":"// reactivestate-core / com.ensody.reactivestate / SuspendMutableValueFlow / update update \u00b6 [common]\\ abstract suspend fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"Update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-suspend-mutable-value-flow/update/#update","text":"[common]\\ abstract suspend fun update (block: (value: T ) -> Unit ) Mutates value in-place and notifies listeners. The current value is passed as an arg.","title":"update"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-value-flow/","text":"// reactivestate-core / com.ensody.reactivestate / ValueFlow ValueFlow \u00b6 [common]\\ interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks. Functions \u00b6 Name Summary collect [common] abstract suspend override fun collect (collector: FlowCollector< T >): Nothing Properties \u00b6 Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T Inheritors \u00b6 Name SuspendMutableValueFlow BaseSuspendMutableValueFlow MutableValueFlow Extensions \u00b6 Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-value-flow/#valueflow","text":"[common]\\ interface ValueFlow < T > : StateFlow< T > A version of StateFlow that can explicitly trigger value changes without equality checks.","title":"ValueFlow"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-value-flow/#functions","text":"Name Summary collect [common] abstract suspend override fun collect (collector: FlowCollector< T >): Nothing","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-value-flow/#properties","text":"Name Summary replayCache [common] abstract val replayCache : List < T > value [common] abstract val value : T","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-value-flow/#inheritors","text":"Name SuspendMutableValueFlow BaseSuspendMutableValueFlow MutableValueFlow","title":"Inheritors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-value-flow/#extensions","text":"Name Summary addDelay [common] fun < T > Flow< T >. addDelay (timeoutMillis: Long ): Flow< T > Adds a timeoutMillis delay to a Flow. If delay is zero or negative this is a no-op. conflatedMap [common] inline fun < T , R > Flow< T >. conflatedMap (timeoutMillis: Long = 0, crossinline transform: suspend (value: T ) -> R ): Flow< R > Maps a conflated Flow with timeoutMillis delay between the first and last element. conflatedTransform [common] inline fun < T , R > Flow< T >. conflatedTransform (timeoutMillis: Long = 0, crossinline transform: suspend FlowCollector< R >.(value: T ) -> Unit ): Flow< R > Transforms a conflated Flow with timeoutMillis delay between the first and last element. conflatedWorker [common] fun < T , R > Flow< T >. conflatedWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using conflatedMap . debounceWorker [common] fun < T , R > Flow< T >. debounceWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and map. latestWorker [common] fun < T , R > Flow< T >. latestWorker (timeoutMillis: Long = 0, transform: FlowTransform < T , R >): Flow< R > Executes each lambda in a Flow using debounce and mapLatest.","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/","text":"// reactivestate-core / com.ensody.reactivestate / WhileUsed WhileUsed \u00b6 [common]\\ class WhileUsed < T >(retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsed is useful for e.g. caches or other resource-consuming values that shouldn\u2019t live forever, but only exist while they\u2019re in use. Sometimes this can also be helpful for dealing with security-critical data. This can be a great combination with SharingStarted.WhileSubscribed and either derived or Flow.stateIn/Flow.shareIn, for example. In order to request the value with invoke you need a CoroutineScope or a DisposableGroup . Note: Your builder function is also passed a DisposableGroup for accessing other WhileUsed instances. The CoroutineScope/ DisposableGroup is used to track the requester\u2019s lifetime and in turn the reference count. As an alternative when you don\u2019t have a CoroutineScope you can also use disposableValue , but this is more error-prone because it\u2019s easier to forget. Typically you\u2019d place such values in your DI system and have one or more ViewModels or UI screens or widgets requesting the value. Once these screens/widgets/ViewModels are destroyed (e.g. because the user pressed on the back button) the value is freed again. Example: val createDatabase = WhileUsed { Database () } val createCache = WhileUsed { DbCache ( createDatabase ( it )) } class MyViewModel : ViewModel () { val cache = createCache ( viewModelScope ) } Parameters \u00b6 common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor). Constructors \u00b6 WhileUsed [common] fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) Functions \u00b6 Name Summary disposableValue [common] fun disposableValue (): DisposableValue < T > Creates or returns the existing value while incrementing the reference count. You really want invoke instead. invoke [common] operator fun invoke (referenceToken: DisposableGroup ): T operator fun invoke (userScope: CoroutineScope): T Creates or returns the existing value while incrementing the reference count.","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/#whileused","text":"[common]\\ class WhileUsed < T >(retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) A reference-counted value that is created on-demand and freed once nobody uses it (whereas by lazy is never freed). WhileUsed is useful for e.g. caches or other resource-consuming values that shouldn\u2019t live forever, but only exist while they\u2019re in use. Sometimes this can also be helpful for dealing with security-critical data. This can be a great combination with SharingStarted.WhileSubscribed and either derived or Flow.stateIn/Flow.shareIn, for example. In order to request the value with invoke you need a CoroutineScope or a DisposableGroup . Note: Your builder function is also passed a DisposableGroup for accessing other WhileUsed instances. The CoroutineScope/ DisposableGroup is used to track the requester\u2019s lifetime and in turn the reference count. As an alternative when you don\u2019t have a CoroutineScope you can also use disposableValue , but this is more error-prone because it\u2019s easier to forget. Typically you\u2019d place such values in your DI system and have one or more ViewModels or UI screens or widgets requesting the value. Once these screens/widgets/ViewModels are destroyed (e.g. because the user pressed on the back button) the value is freed again. Example: val createDatabase = WhileUsed { Database () } val createCache = WhileUsed { DbCache ( createDatabase ( it )) } class MyViewModel : ViewModel () { val cache = createCache ( viewModelScope ) }","title":"WhileUsed"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/#parameters","text":"common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor).","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/#constructors","text":"WhileUsed [common] fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/#functions","text":"Name Summary disposableValue [common] fun disposableValue (): DisposableValue < T > Creates or returns the existing value while incrementing the reference count. You really want invoke instead. invoke [common] operator fun invoke (referenceToken: DisposableGroup ): T operator fun invoke (userScope: CoroutineScope): T Creates or returns the existing value while incrementing the reference count.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/-while-used/","text":"// reactivestate-core / com.ensody.reactivestate / WhileUsed / WhileUsed WhileUsed \u00b6 [common]\\ fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T ) Parameters \u00b6 common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor).","title":" while used"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/-while-used/#whileused","text":"[common]\\ fun < T > WhileUsed (retentionMillis: Long = 0, destructor: ( T ) -> Unit ? = null, builder: ( WhileUsedReferenceToken ) -> T )","title":"WhileUsed"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/-while-used/#parameters","text":"common retentionMillis Defines a retention period in milliseconds in which to still keep the value in RAM although the reference count returned to 0. If the value is requested again within this retention period, the old value is reused. Defaults to 0 (immediately frees the value). destructor Optional destructor which can clean up the object before it gets freed. Defaults to null in which case, if the value is a Disposable , its dispose() method is called. Pass an empty lambda function if you don\u2019t want this behavior. builder Should create and return the value. The builder gets a DisposableGroup as its argument for retrieving other WhileUsed values or for adding other Disposable s which must be cleaned up together with this value (as an alternative to using destructor).","title":"Parameters"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/disposable-value/","text":"// reactivestate-core / com.ensody.reactivestate / WhileUsed / disposableValue disposableValue \u00b6 [common]\\ fun disposableValue (): DisposableValue < T > Creates or returns the existing value while incrementing the reference count. You really want invoke instead. IMPORTANT: You have to call dispose() on the returned value once you stop using it.","title":"Disposable value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/disposable-value/#disposablevalue","text":"[common]\\ fun disposableValue (): DisposableValue < T > Creates or returns the existing value while incrementing the reference count. You really want invoke instead. IMPORTANT: You have to call dispose() on the returned value once you stop using it.","title":"disposableValue"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/invoke/","text":"// reactivestate-core / com.ensody.reactivestate / WhileUsed / invoke invoke \u00b6 [common]\\ operator fun invoke (userScope: CoroutineScope): T Creates or returns the existing value while incrementing the reference count. When the given userScope is canceled the reference count is decremented. Once the count is 0 the value is freed. [common]\\ operator fun invoke (referenceToken: DisposableGroup ): T Creates or returns the existing value while incrementing the reference count. When the given referenceToken is disposed the reference count is decremented. Once the count is 0 the value is freed.","title":"Invoke"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used/invoke/#invoke","text":"[common]\\ operator fun invoke (userScope: CoroutineScope): T Creates or returns the existing value while incrementing the reference count. When the given userScope is canceled the reference count is decremented. Once the count is 0 the value is freed. [common]\\ operator fun invoke (referenceToken: DisposableGroup ): T Creates or returns the existing value while incrementing the reference count. When the given referenceToken is disposed the reference count is decremented. Once the count is 0 the value is freed.","title":"invoke"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/","text":"// reactivestate-core / com.ensody.reactivestate / WhileUsedReferenceToken WhileUsedReferenceToken \u00b6 [common]\\ class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function. Constructors \u00b6 WhileUsedReferenceToken [common] fun WhileUsedReferenceToken () Functions \u00b6 Name Summary add [common] open override fun add (disposable: Disposable ) Add a Disposable to this group. [common] open override fun add (job: Job) Add a Job to this group. dispose [common] open override fun dispose () remove [common] open override fun remove (disposable: Disposable ) Remove a Disposable from this group. [common] open override fun remove (job: Job) Remove a Job from this group. Properties \u00b6 Name Summary scope [common] val scope : CoroutineScope A lazily created MainScope that lives only as long as the WhileUsed value. size [common] open override val size : Int Extensions \u00b6 Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/#whileusedreferencetoken","text":"[common]\\ class WhileUsedReferenceToken : DisposableGroup The reference token passed to the WhileUsed builder function.","title":"WhileUsedReferenceToken"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/#constructors","text":"WhileUsedReferenceToken [common] fun WhileUsedReferenceToken ()","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/#functions","text":"Name Summary add [common] open override fun add (disposable: Disposable ) Add a Disposable to this group. [common] open override fun add (job: Job) Add a Job to this group. dispose [common] open override fun dispose () remove [common] open override fun remove (disposable: Disposable ) Remove a Disposable from this group. [common] open override fun remove (job: Job) Remove a Job from this group.","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/#properties","text":"Name Summary scope [common] val scope : CoroutineScope A lazily created MainScope that lives only as long as the WhileUsed value. size [common] open override val size : Int","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/#extensions","text":"Name Summary disposeOnCompletionOf [common] fun Disposable . disposeOnCompletionOf (job: Job): Disposable Disposes the Disposable when Job completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (context: CoroutineContext ): Disposable Disposes the Disposable when CoroutineContext completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (scope: CoroutineScope): Disposable Disposes the Disposable when CoroutineScope completes (including cancellation). [common] fun Disposable . disposeOnCompletionOf (launcher: CoroutineLauncher ): Disposable Disposes the Disposable when CoroutineLauncher completes (including cancellation).","title":"Extensions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/-while-used-reference-token/","text":"// reactivestate-core / com.ensody.reactivestate / WhileUsedReferenceToken / WhileUsedReferenceToken WhileUsedReferenceToken \u00b6 [common]\\ fun WhileUsedReferenceToken ()","title":" while used reference token"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/-while-used-reference-token/#whileusedreferencetoken","text":"[common]\\ fun WhileUsedReferenceToken ()","title":"WhileUsedReferenceToken"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/scope/","text":"// reactivestate-core / com.ensody.reactivestate / WhileUsedReferenceToken / scope scope \u00b6 [common]\\ val scope : CoroutineScope A lazily created MainScope that lives only as long as the WhileUsed value.","title":"Scope"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-while-used-reference-token/scope/#scope","text":"[common]\\ val scope : CoroutineScope A lazily created MainScope that lives only as long as the WhileUsed value.","title":"scope"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/","text":"// reactivestate-core / com.ensody.reactivestate / Wrapped Wrapped \u00b6 [common]\\ class Wrapped < T >(val value: T ) : Serializable , ReadOnlyProperty < Any ?, T > Wraps a value. Together with nullability can model an Option / Maybe . Constructors \u00b6 Wrapped [common] fun < T > Wrapped (value: T ) Functions \u00b6 Name Summary getValue [common] open operator override fun getValue (thisRef: Any ?, property: KProperty <*>): T Properties \u00b6 Name Summary value [common] val value : T","title":"Index"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/#wrapped","text":"[common]\\ class Wrapped < T >(val value: T ) : Serializable , ReadOnlyProperty < Any ?, T > Wraps a value. Together with nullability can model an Option / Maybe .","title":"Wrapped"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/#constructors","text":"Wrapped [common] fun < T > Wrapped (value: T )","title":"Constructors"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/#functions","text":"Name Summary getValue [common] open operator override fun getValue (thisRef: Any ?, property: KProperty <*>): T","title":"Functions"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/#properties","text":"Name Summary value [common] val value : T","title":"Properties"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/-wrapped/","text":"// reactivestate-core / com.ensody.reactivestate / Wrapped / Wrapped Wrapped \u00b6 [common]\\ fun < T > Wrapped (value: T )","title":" wrapped"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/-wrapped/#wrapped","text":"[common]\\ fun < T > Wrapped (value: T )","title":"Wrapped"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/get-value/","text":"// reactivestate-core / com.ensody.reactivestate / Wrapped / getValue getValue \u00b6 [common]\\ open operator override fun getValue (thisRef: Any ?, property: KProperty <*>): T","title":"Get value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/get-value/#getvalue","text":"[common]\\ open operator override fun getValue (thisRef: Any ?, property: KProperty <*>): T","title":"getValue"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/value/","text":"// reactivestate-core / com.ensody.reactivestate / Wrapped / value value \u00b6 [common]\\ val value : T","title":"Value"},{"location":"reference/reactivestate-core/com.ensody.reactivestate/-wrapped/value/#value","text":"[common]\\ val value : T","title":"value"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test Package-level declarations \u00b6 Types \u00b6 Name Summary CoroutineTest [common] open class CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. CoroutineTestRule [common] open class CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) Helper class for unit Tests that sets up dispatchers with a TestDispatcherConfig on every test run. EventNotifierTest [common] abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. ReactiveStateTest [common] abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. TestDispatcherConfig [common] class TestDispatcherConfig (val dispatcher: TestDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher .","title":"Index"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/#types","text":"Name Summary CoroutineTest [common] open class CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. CoroutineTestRule [common] open class CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) Helper class for unit Tests that sets up dispatchers with a TestDispatcherConfig on every test run. EventNotifierTest [common] abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. ReactiveStateTest [common] abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. TestDispatcherConfig [common] class TestDispatcherConfig (val dispatcher: TestDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher .","title":"Types"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTest CoroutineTest \u00b6 [common]\\ open class CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. On every test run this class automatically sets MainScope and dispatchers to use a TestCoroutineDispatcher . Internally, this uses a CoroutineTestRule which does the actual dispatchers and Dispatchers.setMain() setup. This allows accessing e.g. the testScope in your @Before setup method. Moreover, this provides an attachedDisposables attribute and a collectFlow helper, so you can activate SharingStarted.WhileSubscribed based flows created with derived, for example. Constructors \u00b6 CoroutineTest [common] fun CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) Functions \u00b6 Name Summary collectFlow [common] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose [common] open override fun dispose () enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ). Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup mainScope [common] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope Inheritors \u00b6 Name EventNotifierTest","title":"Index"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/#coroutinetest","text":"[common]\\ open class CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) : CoroutineTestRule , AttachedDisposables Base class for unit testing coroutine based code. On every test run this class automatically sets MainScope and dispatchers to use a TestCoroutineDispatcher . Internally, this uses a CoroutineTestRule which does the actual dispatchers and Dispatchers.setMain() setup. This allows accessing e.g. the testScope in your @Before setup method. Moreover, this provides an attachedDisposables attribute and a collectFlow helper, so you can activate SharingStarted.WhileSubscribed based flows created with derived, for example.","title":"CoroutineTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/#constructors","text":"CoroutineTest [common] fun CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) })","title":"Constructors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/#functions","text":"Name Summary collectFlow [common] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose [common] open override fun dispose () enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ).","title":"Functions"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup mainScope [common] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope","title":"Properties"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/#inheritors","text":"Name EventNotifierTest","title":"Inheritors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/-coroutine-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTest / CoroutineTest CoroutineTest \u00b6 [common]\\ fun CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) })","title":" coroutine test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/-coroutine-test/#coroutinetest","text":"[common]\\ fun CoroutineTest (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) })","title":"CoroutineTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/attached-disposables/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTest / attachedDisposables attachedDisposables \u00b6 [common]\\ open override val attachedDisposables : DisposableGroup","title":"Attached disposables"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/attached-disposables/#attacheddisposables","text":"[common]\\ open override val attachedDisposables : DisposableGroup","title":"attachedDisposables"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/collect-flow/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTest / collectFlow collectFlow \u00b6 [common]\\ fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background.","title":"Collect flow"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/collect-flow/#collectflow","text":"[common]\\ fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background.","title":"collectFlow"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/run-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTest / runTest runTest \u00b6 [common]\\ open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ).","title":"Run test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test/run-test/#runtest","text":"[common]\\ open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow ).","title":"runTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule CoroutineTestRule \u00b6 [common]\\ open class CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) Helper class for unit Tests that sets up dispatchers with a TestDispatcherConfig on every test run. Also, Dispatchers.Main is set to a TestScope. This rule allows for e.g. setup methods with @Before which need access to the TestScope. Use the runTest method provided by this rule instead of the one provided by the coroutines library. You can also access the testScope and testDispatcher in case you need them to e.g. launch some background process during each test. Constructors \u00b6 CoroutineTestRule [common] fun CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) Functions \u00b6 Name Summary enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open fun runTest (block: suspend TestScope.() -> Unit ): TestResult Properties \u00b6 Name Summary mainScope [common] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope Inheritors \u00b6 Name CoroutineTest","title":"Index"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/#coroutinetestrule","text":"[common]\\ open class CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) }) Helper class for unit Tests that sets up dispatchers with a TestDispatcherConfig on every test run. Also, Dispatchers.Main is set to a TestScope. This rule allows for e.g. setup methods with @Before which need access to the TestScope. Use the runTest method provided by this rule instead of the one provided by the coroutines library. You can also access the testScope and testDispatcher in case you need them to e.g. launch some background process during each test.","title":"CoroutineTestRule"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/#constructors","text":"CoroutineTestRule [common] fun CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) })","title":"Constructors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/#functions","text":"Name Summary enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open fun runTest (block: suspend TestScope.() -> Unit ): TestResult","title":"Functions"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/#properties","text":"Name Summary mainScope [common] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope","title":"Properties"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/#inheritors","text":"Name CoroutineTest","title":"Inheritors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/-coroutine-test-rule/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / CoroutineTestRule CoroutineTestRule \u00b6 [common]\\ fun CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) })","title":" coroutine test rule"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/-coroutine-test-rule/#coroutinetestrule","text":"[common]\\ fun CoroutineTestRule (testDispatcherBuilder: (TestCoroutineScheduler) -> TestDispatcher = { StandardTestDispatcher(it) })","title":"CoroutineTestRule"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/enter-coroutine-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / enterCoroutineTest enterCoroutineTest \u00b6 [common]\\ fun enterCoroutineTest ()","title":"Enter coroutine test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/enter-coroutine-test/#entercoroutinetest","text":"[common]\\ fun enterCoroutineTest ()","title":"enterCoroutineTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/exit-coroutine-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / exitCoroutineTest exitCoroutineTest \u00b6 [common]\\ fun exitCoroutineTest ()","title":"Exit coroutine test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/exit-coroutine-test/#exitcoroutinetest","text":"[common]\\ fun exitCoroutineTest ()","title":"exitCoroutineTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/main-scope/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / mainScope mainScope \u00b6 [common]\\ val ~~mainScope~~ : CoroutineScope Deprecated \u00b6 Use testScope.backgroundScope Replace with \u00b6 testScope . backgroundScope \u00b6","title":"Main scope"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/main-scope/#mainscope","text":"[common]\\ val ~~mainScope~~ : CoroutineScope","title":"mainScope"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/main-scope/#deprecated","text":"Use testScope.backgroundScope","title":"Deprecated"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/main-scope/#replace-with","text":"","title":"Replace with"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/main-scope/#testscopebackgroundscope","text":"","title":"testScope.backgroundScope\n"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-blocking-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / runBlockingTest runBlockingTest \u00b6 [common]\\ open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult Deprecated \u00b6 Use runTest instead Replace with \u00b6 runTest ( block ) \u00b6","title":"Run blocking test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-blocking-test/#runblockingtest","text":"[common]\\ open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult","title":"runBlockingTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-blocking-test/#deprecated","text":"Use runTest instead","title":"Deprecated"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-blocking-test/#replace-with","text":"","title":"Replace with"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-blocking-test/#runtestblock","text":"","title":"runTest(block)\n"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / runTest runTest \u00b6 [common]\\ open fun runTest (block: suspend TestScope.() -> Unit ): TestResult","title":"Run test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/run-test/#runtest","text":"[common]\\ open fun runTest (block: suspend TestScope.() -> Unit ): TestResult","title":"runTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-dispatcher/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / testCoroutineDispatcher testCoroutineDispatcher \u00b6 [common]\\ val ~~testCoroutineDispatcher~~ : TestDispatcher Deprecated \u00b6 Use testDispatcher Replace with \u00b6 testDispatcher \u00b6","title":"Test coroutine dispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-dispatcher/#testcoroutinedispatcher","text":"[common]\\ val ~~testCoroutineDispatcher~~ : TestDispatcher","title":"testCoroutineDispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-dispatcher/#deprecated","text":"Use testDispatcher","title":"Deprecated"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-dispatcher/#replace-with","text":"","title":"Replace with"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-dispatcher/#testdispatcher","text":"","title":"testDispatcher\n"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-scope/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / testCoroutineScope testCoroutineScope \u00b6 [common]\\ val ~~testCoroutineScope~~ : TestScope Deprecated \u00b6 Use testScope Replace with \u00b6 testScope \u00b6","title":"Test coroutine scope"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-scope/#testcoroutinescope","text":"[common]\\ val ~~testCoroutineScope~~ : TestScope","title":"testCoroutineScope"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-scope/#deprecated","text":"Use testScope","title":"Deprecated"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-scope/#replace-with","text":"","title":"Replace with"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-coroutine-scope/#testscope","text":"","title":"testScope\n"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-dispatcher/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / testDispatcher testDispatcher \u00b6 [common]\\ val testDispatcher : TestDispatcher","title":"Test dispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-dispatcher/#testdispatcher","text":"[common]\\ val testDispatcher : TestDispatcher","title":"testDispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-scope/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / CoroutineTestRule / testScope testScope \u00b6 [common]\\ val testScope : TestScope","title":"Test scope"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-coroutine-test-rule/test-scope/#testscope","text":"[common]\\ val testScope : TestScope","title":"testScope"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest EventNotifierTest \u00b6 [common]\\ abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runTest . You can disable this by overriding handleEventsInRunTest to false . In that case you have to explicitly call handleEvents in each test. Constructors \u00b6 EventNotifierTest [common] fun EventNotifierTest () Functions \u00b6 Name Summary collectFlow [common] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose [common] open override fun dispose () enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () handleEvents [common] fun handleEvents () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow). Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup eventNotifier [common] abstract val eventNotifier : EventNotifier< E > events [common] abstract val events : E eventsDispatcher [common] open val eventsDispatcher : TestDispatcher The dispatcher to use for handleEvents . handleEventsInRunTest [common] open val handleEventsInRunTest : Boolean = true mainScope [common] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope Inheritors \u00b6 Name ReactiveStateTest","title":"Index"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/#eventnotifiertest","text":"[common]\\ abstract class EventNotifierTest < E > : CoroutineTest Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runTest . You can disable this by overriding handleEventsInRunTest to false . In that case you have to explicitly call handleEvents in each test.","title":"EventNotifierTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/#constructors","text":"EventNotifierTest [common] fun EventNotifierTest ()","title":"Constructors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/#functions","text":"Name Summary collectFlow [common] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose [common] open override fun dispose () enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () handleEvents [common] fun handleEvents () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"Functions"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup eventNotifier [common] abstract val eventNotifier : EventNotifier< E > events [common] abstract val events : E eventsDispatcher [common] open val eventsDispatcher : TestDispatcher The dispatcher to use for handleEvents . handleEventsInRunTest [common] open val handleEventsInRunTest : Boolean = true mainScope [common] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope","title":"Properties"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/#inheritors","text":"Name ReactiveStateTest","title":"Inheritors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/-event-notifier-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest / EventNotifierTest EventNotifierTest \u00b6 [common]\\ fun EventNotifierTest ()","title":" event notifier test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/-event-notifier-test/#eventnotifiertest","text":"[common]\\ fun EventNotifierTest ()","title":"EventNotifierTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/event-notifier/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest / eventNotifier eventNotifier \u00b6 [common]\\ abstract val eventNotifier : EventNotifier< E >","title":"Event notifier"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/event-notifier/#eventnotifier","text":"[common]\\ abstract val eventNotifier : EventNotifier< E >","title":"eventNotifier"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/events-dispatcher/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest / eventsDispatcher eventsDispatcher \u00b6 [common]\\ open val eventsDispatcher : TestDispatcher The dispatcher to use for handleEvents .","title":"Events dispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/events-dispatcher/#eventsdispatcher","text":"[common]\\ open val eventsDispatcher : TestDispatcher The dispatcher to use for handleEvents .","title":"eventsDispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/events/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest / events events \u00b6 [common]\\ abstract val events : E","title":"Events"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/events/#events","text":"[common]\\ abstract val events : E","title":"events"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events-in-run-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest / handleEventsInRunTest handleEventsInRunTest \u00b6 [common]\\ open val handleEventsInRunTest : Boolean = true","title":"Handle events in run test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events-in-run-test/#handleeventsinruntest","text":"[common]\\ open val handleEventsInRunTest : Boolean = true","title":"handleEventsInRunTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest / handleEvents handleEvents \u00b6 [common]\\ fun handleEvents ()","title":"Handle events"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/handle-events/#handleevents","text":"[common]\\ fun handleEvents ()","title":"handleEvents"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/run-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / EventNotifierTest / runTest runTest \u00b6 [common]\\ open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"Run test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-event-notifier-test/run-test/#runtest","text":"[common]\\ open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"runTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / ReactiveStateTest ReactiveStateTest \u00b6 [common]\\ abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runTest. You can disable this by overriding handleEventsInRunTest to false . In that case you have to explicitly call handleEvents in each test. Constructors \u00b6 ReactiveStateTest [common] fun ReactiveStateTest () Functions \u00b6 Name Summary collectFlow [common] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose [common] open override fun dispose () enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () handleEvents [common] fun handleEvents () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow). Properties \u00b6 Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup eventNotifier [common] open override val eventNotifier : EventNotifier< E > events [common] abstract val events : E eventsDispatcher [common] open val eventsDispatcher : TestDispatcher The dispatcher to use for handleEvents . handleEventsInRunTest [common] open val handleEventsInRunTest : Boolean mainScope [common] val ~~mainScope~~ : CoroutineScope reactiveState [common] abstract val reactiveState : ReactiveState< E > testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope","title":"Index"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/#reactivestatetest","text":"[common]\\ abstract class ReactiveStateTest < E : ErrorEvents> : EventNotifierTest < E > Base class for unit testing an EventNotifier. You have to override the eventNotifier and events attributes. Usually, events will be a mock. By default this handles events in runTest. You can disable this by overriding handleEventsInRunTest to false . In that case you have to explicitly call handleEvents in each test.","title":"ReactiveStateTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/#constructors","text":"ReactiveStateTest [common] fun ReactiveStateTest ()","title":"Constructors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/#functions","text":"Name Summary collectFlow [common] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit = {}) Collects a flow in the background. dispose [common] open override fun dispose () enterCoroutineTest [common] fun enterCoroutineTest () exitCoroutineTest [common] fun exitCoroutineTest () handleEvents [common] fun handleEvents () runBlockingTest [common] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [common] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult In addition to running the test this also disposes the attachedDisposables (useful with collectFlow).","title":"Functions"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/#properties","text":"Name Summary attachedDisposables [common] open override val attachedDisposables : DisposableGroup eventNotifier [common] open override val eventNotifier : EventNotifier< E > events [common] abstract val events : E eventsDispatcher [common] open val eventsDispatcher : TestDispatcher The dispatcher to use for handleEvents . handleEventsInRunTest [common] open val handleEventsInRunTest : Boolean mainScope [common] val ~~mainScope~~ : CoroutineScope reactiveState [common] abstract val reactiveState : ReactiveState< E > testCoroutineDispatcher [common] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [common] val ~~testCoroutineScope~~ : TestScope testDispatcher [common] val testDispatcher : TestDispatcher testScope [common] val testScope : TestScope","title":"Properties"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/-reactive-state-test/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / ReactiveStateTest / ReactiveStateTest ReactiveStateTest \u00b6 [common]\\ fun ReactiveStateTest ()","title":" reactive state test"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/-reactive-state-test/#reactivestatetest","text":"[common]\\ fun ReactiveStateTest ()","title":"ReactiveStateTest"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/event-notifier/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / ReactiveStateTest / eventNotifier eventNotifier \u00b6 [common]\\ open override val eventNotifier : EventNotifier< E >","title":"Event notifier"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/event-notifier/#eventnotifier","text":"[common]\\ open override val eventNotifier : EventNotifier< E >","title":"eventNotifier"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/reactive-state/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / ReactiveStateTest / reactiveState reactiveState \u00b6 [common]\\ abstract val reactiveState : ReactiveState< E >","title":"Reactive state"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-reactive-state-test/reactive-state/#reactivestate","text":"[common]\\ abstract val reactiveState : ReactiveState< E >","title":"reactiveState"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / TestDispatcherConfig TestDispatcherConfig \u00b6 [common]\\ class TestDispatcherConfig (val dispatcher: TestDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher . Constructors \u00b6 TestDispatcherConfig [common] fun TestDispatcherConfig (dispatcher: TestDispatcher) Properties \u00b6 Name Summary default [common] open override val default : TestDispatcher dispatcher [common] val dispatcher : TestDispatcher io [common] open override val io : TestDispatcher main [common] open override val main : TestDispatcher unconfined [common] open override val unconfined : TestDispatcher","title":"Index"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/#testdispatcherconfig","text":"[common]\\ class TestDispatcherConfig (val dispatcher: TestDispatcher) : CoroutineDispatcherConfig A CoroutineDispatcherConfig for unit tests - dispatching everything to the given dispatcher .","title":"TestDispatcherConfig"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/#constructors","text":"TestDispatcherConfig [common] fun TestDispatcherConfig (dispatcher: TestDispatcher)","title":"Constructors"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/#properties","text":"Name Summary default [common] open override val default : TestDispatcher dispatcher [common] val dispatcher : TestDispatcher io [common] open override val io : TestDispatcher main [common] open override val main : TestDispatcher unconfined [common] open override val unconfined : TestDispatcher","title":"Properties"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/-test-dispatcher-config/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / TestDispatcherConfig / TestDispatcherConfig TestDispatcherConfig \u00b6 [common]\\ fun TestDispatcherConfig (dispatcher: TestDispatcher)","title":" test dispatcher config"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/-test-dispatcher-config/#testdispatcherconfig","text":"[common]\\ fun TestDispatcherConfig (dispatcher: TestDispatcher)","title":"TestDispatcherConfig"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/default/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / TestDispatcherConfig / default default \u00b6 [common]\\ open override val default : TestDispatcher","title":"Default"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/default/#default","text":"[common]\\ open override val default : TestDispatcher","title":"default"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/dispatcher/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / TestDispatcherConfig / dispatcher dispatcher \u00b6 [common]\\ val dispatcher : TestDispatcher","title":"Dispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/dispatcher/#dispatcher","text":"[common]\\ val dispatcher : TestDispatcher","title":"dispatcher"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/io/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / TestDispatcherConfig / io io \u00b6 [common]\\ open override val io : TestDispatcher","title":"Io"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/io/#io","text":"[common]\\ open override val io : TestDispatcher","title":"io"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/main/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / TestDispatcherConfig / main main \u00b6 [common]\\ open override val main : TestDispatcher","title":"Main"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/main/#main","text":"[common]\\ open override val main : TestDispatcher","title":"main"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/unconfined/","text":"// reactivestate-core-test / com.ensody.reactivestate.test / TestDispatcherConfig / unconfined unconfined \u00b6 [common]\\ open override val unconfined : TestDispatcher","title":"Unconfined"},{"location":"reference/reactivestate-core-test/com.ensody.reactivestate.test/-test-dispatcher-config/unconfined/#unconfined","text":"[common]\\ open override val unconfined : TestDispatcher","title":"unconfined"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/","text":"// reactivestate-test / com.ensody.reactivestate.test Package-level declarations \u00b6 Types \u00b6 Name Summary AndroidCoroutineTest [android] open class AndroidCoroutineTest : CoroutineTest A CoroutineTest that also sets up an InstantTaskExecutorRule .","title":"reactivestate-test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/#package-level-declarations","text":"","title":"Package-level declarations"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/#types","text":"Name Summary AndroidCoroutineTest [android] open class AndroidCoroutineTest : CoroutineTest A CoroutineTest that also sets up an InstantTaskExecutorRule .","title":"Types"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / AndroidCoroutineTest AndroidCoroutineTest \u00b6 [android]\\ open class AndroidCoroutineTest : CoroutineTest A CoroutineTest that also sets up an InstantTaskExecutorRule . Constructors \u00b6 AndroidCoroutineTest [android] fun AndroidCoroutineTest () Functions \u00b6 Name Summary collectFlow [android] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit ) dispose [android] open override fun dispose () enterCoroutineTest [android] fun enterCoroutineTest () exitCoroutineTest [android] fun exitCoroutineTest () runBlockingTest [android] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [android] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult Properties \u00b6 Name Summary attachedDisposables [android] open override val attachedDisposables : DisposableGroup instantTaskExecutorRule [android] val instantTaskExecutorRule : InstantTaskExecutorRule mainScope [android] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [android] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [android] val ~~testCoroutineScope~~ : TestScope testDispatcher [android] val testDispatcher : TestDispatcher testScope [android] val testScope : TestScope","title":"Index"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/#androidcoroutinetest","text":"[android]\\ open class AndroidCoroutineTest : CoroutineTest A CoroutineTest that also sets up an InstantTaskExecutorRule .","title":"AndroidCoroutineTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/#constructors","text":"AndroidCoroutineTest [android] fun AndroidCoroutineTest ()","title":"Constructors"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/#functions","text":"Name Summary collectFlow [android] fun < T > TestScope. collectFlow (flow: Flow< T >, collector: suspend ( T ) -> Unit ) dispose [android] open override fun dispose () enterCoroutineTest [android] fun enterCoroutineTest () exitCoroutineTest [android] fun exitCoroutineTest () runBlockingTest [android] open fun ~~runBlockingTest~~ (block: suspend TestScope.() -> Unit ): TestResult runTest [android] open override fun runTest (block: suspend TestScope.() -> Unit ): TestResult","title":"Functions"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/#properties","text":"Name Summary attachedDisposables [android] open override val attachedDisposables : DisposableGroup instantTaskExecutorRule [android] val instantTaskExecutorRule : InstantTaskExecutorRule mainScope [android] val ~~mainScope~~ : CoroutineScope testCoroutineDispatcher [android] val ~~testCoroutineDispatcher~~ : TestDispatcher testCoroutineScope [android] val ~~testCoroutineScope~~ : TestScope testDispatcher [android] val testDispatcher : TestDispatcher testScope [android] val testScope : TestScope","title":"Properties"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/-android-coroutine-test/","text":"// reactivestate-test / com.ensody.reactivestate.test / AndroidCoroutineTest / AndroidCoroutineTest AndroidCoroutineTest \u00b6 [android]\\ fun AndroidCoroutineTest ()","title":" android coroutine test"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/-android-coroutine-test/#androidcoroutinetest","text":"[android]\\ fun AndroidCoroutineTest ()","title":"AndroidCoroutineTest"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/instant-task-executor-rule/","text":"// reactivestate-test / com.ensody.reactivestate.test / AndroidCoroutineTest / instantTaskExecutorRule instantTaskExecutorRule \u00b6 [android]\\ val instantTaskExecutorRule : InstantTaskExecutorRule","title":"Instant task executor rule"},{"location":"reference/reactivestate-test/com.ensody.reactivestate.test/-android-coroutine-test/instant-task-executor-rule/#instanttaskexecutorrule","text":"[android]\\ val instantTaskExecutorRule : InstantTaskExecutorRule","title":"instantTaskExecutorRule"}]}